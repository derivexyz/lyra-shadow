{
  "compilerVersion": "v0.8.18+commit.87f61d96",
  "language": "Solidity",
  "remappings": [
    "forge-std=lib/forge-std/src/",
    "lib/lyra-utils=lib/lyra-utils/",
    "lib/openzeppelin-contracts=lib/openzeppelin-contracts/",
    "src/risk-managers=src/risk-managers/",
    "src/interfaces=src/interfaces/",
    "forge-std/=lib/forge-std/src/",
    "openzeppelin/=lib/openzeppelin-contracts/contracts/",
    "openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
    "chainlink/=lib/chainlink/",
    "lyra-utils/=lib/lyra-utils/src/",
    "src/decimals/=lib/lyra-utils/src/decimals/",
    "ds-test/=lib/forge-std/lib/ds-test/src/",
    "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
    "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/",
    "openzeppelin-contracts/=lib/openzeppelin-contracts/"
  ],
  "contractFiles": [
    {
      "fileName": "lib/lyra-utils/src/encoding/OptionEncoding.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title OptionEncoding\n * @author Lyra\n * @notice Util functions for encoding / decoding IDs into option details.\n *         [ 1 bit ] [ 63 bits ] [ 32 bit ] = uint96 subId\n *           isCall     strike     expiry\n *         Can support:\n *         - expiries: up to year 2106\n *         - strikes: down to 8 decimal points and up to $90B\n */\nlibrary OptionEncoding {\n  uint constant UINT32_MAX = 0xffffffff; // 4294967295;\n  uint constant UINT63_MAX = 0x7fffffffffffffff; // 9223372036854775807;\n\n  /**\n   * @dev Convert option details into subId\n   * @param expiry timestamp of expiry\n   * @param strike 18 decimal strike price\n   * @param isCall if call, then true\n   * @return subId ID of option\n   */\n  function toSubId(uint expiry, uint strike, bool isCall) internal pure returns (uint96 subId) {\n    // can support expiry up to year 2106\n    if (expiry > UINT32_MAX) {\n      revert OE_ExpiryTooLarge(expiry);\n    }\n\n    // zero expiry guaranteed to not be possible\n    if (expiry == 0) {\n      revert OE_ZeroExpiry();\n    }\n\n    // can support strike granularity down to 8 decimal points\n    if (strike % 1e10 > 0) {\n      revert OE_StrikeTooGranular(strike);\n    }\n\n    // convert to 8 decimal points\n    strike = strike / 1e10;\n\n    // can support strike as high as $92,233,720,368\n    if (strike > UINT63_MAX) {\n      revert OE_StrikeTooLarge(strike);\n    }\n\n    uint96 shiftedStrike = uint96(strike) << 32;\n    uint96 shiftedIsCall = uint96((isCall) ? 1 : 0) << 95;\n    subId = uint96(expiry) | shiftedStrike | shiftedIsCall;\n  }\n\n  /**\n   * @dev Convert subId into option details\n   * @param subId ID of option\n   * @return expiry timestamp of expiry\n   * @return strike 18 decimal strike price\n   * @return isCall if call, then true\n   */\n  function fromSubId(uint96 subId) internal pure returns (uint expiry, uint strike, bool isCall) {\n    expiry = subId & UINT32_MAX;\n    strike = ((subId >> 32) & UINT63_MAX) * 1e10;\n    isCall = (subId >> 95) > 0;\n  }\n\n  ////////////\n  // Errors //\n  ////////////\n\n  error OE_ExpiryTooLarge(uint expiry);\n  error OE_ZeroExpiry();\n  error OE_StrikeTooLarge(uint strike);\n  error OE_StrikeTooGranular(uint strike);\n}\n"
    },
    {
      "fileName": "lib/lyra-utils/src/decimals/SignedDecimalMath.sol",
      "content": "//SPDX-License-Identifier: MIT\n//\n//Copyright (c) 2019 Synthetix\n//\n//Permission is hereby granted, free of charge, to any person obtaining a copy\n//of this software and associated documentation files (the \"Software\"), to deal\n//in the Software without restriction, including without limitation the rights\n//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n//copies of the Software, and to permit persons to whom the Software is\n//furnished to do so, subject to the following conditions:\n//\n//The above copyright notice and this permission notice shall be included in all\n//copies or substantial portions of the Software.\n//\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n//SOFTWARE.\n\npragma solidity ^0.8.0;\n\n/**\n * @title SignedDecimalMath\n * @author Lyra\n * @dev Modified synthetix SafeSignedDecimalMath to include internal arithmetic underflow/overflow.\n * @dev https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\n */\nlibrary SignedDecimalMath {\n  /* Number of decimal places in the representations. */\n  uint8 public constant decimals = 18;\n  uint8 public constant highPrecisionDecimals = 27;\n\n  /* The number representing 1.0. */\n  int public constant UNIT = int(10 ** uint(decimals));\n\n  /* The number representing 1.0 for higher fidelity numbers. */\n  int public constant PRECISE_UNIT = int(10 ** uint(highPrecisionDecimals));\n  int private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = int(10 ** uint(highPrecisionDecimals - decimals));\n\n  /**\n   * @return Provides an interface to UNIT.\n   */\n  function unit() external pure returns (int) {\n    return UNIT;\n  }\n\n  /**\n   * @return Provides an interface to PRECISE_UNIT.\n   */\n  function preciseUnit() external pure returns (int) {\n    return PRECISE_UNIT;\n  }\n\n  /**\n   * @dev Rounds an input with an extra zero of precision, returning the result without the extra zero.\n   * Half increments round away from zero; positive numbers at a half increment are rounded up,\n   * while negative such numbers are rounded down. This behaviour is designed to be consistent with the\n   * unsigned version of this library (SafeDecimalMath).\n   */\n  function _roundDividingByTen(int valueTimesTen) private pure returns (int) {\n    int increment;\n    if (valueTimesTen % 10 >= 5) {\n      increment = 10;\n    } else if (valueTimesTen % 10 <= -5) {\n      increment = -10;\n    }\n    return (valueTimesTen + increment) / 10;\n  }\n\n  /**\n   * @return The result of multiplying x and y, interpreting the operands as fixed-point\n   * decimals.\n   *\n   * @dev A unit factor is divided out after the product of x and y is evaluated,\n   * so that product must be less than 2**256. As this is an integer division,\n   * the internal division always rounds down. This helps save on gas. Rounding\n   * is more expensive on gas.\n   */\n  function multiplyDecimal(int x, int y) internal pure returns (int) {\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\n    return (x * y) / UNIT;\n  }\n\n  /**\n   * @return The result of safely multiplying x and y, interpreting the operands\n   * as fixed-point decimals of the specified precision unit.\n   *\n   * @dev The operands should be in the form of a the specified unit factor which will be\n   * divided out after the product of x and y is evaluated, so that product must be\n   * less than 2**256.\n   *\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\n   * (eg. small fractions or percentages).\n   */\n  function _multiplyDecimalRound(int x, int y, int precisionUnit) private pure returns (int) {\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\n    int quotientTimesTen = (x * y) / (precisionUnit / 10);\n    return _roundDividingByTen(quotientTimesTen);\n  }\n\n  /**\n   * @return The result of safely multiplying x and y, interpreting the operands\n   * as fixed-point decimals of a precise unit.\n   *\n   * @dev The operands should be in the precise unit factor which will be\n   * divided out after the product of x and y is evaluated, so that product must be\n   * less than 2**256.\n   *\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\n   * (eg. small fractions or percentages).\n   */\n  function multiplyDecimalRoundPrecise(int x, int y) internal pure returns (int) {\n    return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n  }\n\n  /**\n   * @return The result of safely multiplying x and y, interpreting the operands\n   * as fixed-point decimals of a standard unit.\n   *\n   * @dev The operands should be in the standard unit factor which will be\n   * divided out after the product of x and y is evaluated, so that product must be\n   * less than 2**256.\n   *\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\n   * (eg. small fractions or percentages).\n   */\n  function multiplyDecimalRound(int x, int y) internal pure returns (int) {\n    return _multiplyDecimalRound(x, y, UNIT);\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is a high\n   * precision decimal.\n   *\n   * @dev y is divided after the product of x and the standard precision unit\n   * is evaluated, so the product of x and UNIT must be less than 2**256. As\n   * this is an integer division, the result is always rounded down.\n   * This helps save on gas. Rounding is more expensive on gas.\n   */\n  function divideDecimal(int x, int y) internal pure returns (int) {\n    /* Reintroduce the UNIT factor that will be divided out by y. */\n    return (x * UNIT) / y;\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is as a rounded\n   * decimal in the precision unit specified in the parameter.\n   *\n   * @dev y is divided after the product of x and the specified precision unit\n   * is evaluated, so the product of x and the specified precision unit must\n   * be less than 2**256. The result is rounded to the nearest increment.\n   */\n  function _divideDecimalRound(int x, int y, int precisionUnit) private pure returns (int) {\n    int resultTimesTen = (x * (precisionUnit * 10)) / y;\n    return _roundDividingByTen(resultTimesTen);\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is as a rounded\n   * standard precision decimal.\n   *\n   * @dev y is divided after the product of x and the standard precision unit\n   * is evaluated, so the product of x and the standard precision unit must\n   * be less than 2**256. The result is rounded to the nearest increment.\n   */\n  function divideDecimalRound(int x, int y) internal pure returns (int) {\n    return _divideDecimalRound(x, y, UNIT);\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is as a rounded\n   * high precision decimal.\n   *\n   * @dev y is divided after the product of x and the high precision unit\n   * is evaluated, so the product of x and the high precision unit must\n   * be less than 2**256. The result is rounded to the nearest increment.\n   */\n  function divideDecimalRoundPrecise(int x, int y) internal pure returns (int) {\n    return _divideDecimalRound(x, y, PRECISE_UNIT);\n  }\n\n  /**\n   * @dev Convert a standard decimal representation to a high precision one.\n   */\n  function decimalToPreciseDecimal(int i) internal pure returns (int) {\n    return i * UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR;\n  }\n\n  /**\n   * @dev Convert a high precision decimal to a standard decimal representation.\n   */\n  function preciseDecimalToDecimal(int i) internal pure returns (int) {\n    int quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n    return _roundDividingByTen(quotientTimesTen);\n  }\n}\n"
    },
    {
      "fileName": "lib/lyra-utils/src/decimals/DecimalMath.sol",
      "content": "//SPDX-License-Identifier: MIT\n//\n//Copyright (c) 2019 Synthetix\n//\n//Permission is hereby granted, free of charge, to any person obtaining a copy\n//of this software and associated documentation files (the \"Software\"), to deal\n//in the Software without restriction, including without limitation the rights\n//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n//copies of the Software, and to permit persons to whom the Software is\n//furnished to do so, subject to the following conditions:\n//\n//The above copyright notice and this permission notice shall be included in all\n//copies or substantial portions of the Software.\n//\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n//SOFTWARE.\n\npragma solidity ^0.8.0;\n\n/**\n * @title DecimalMath\n * @author Lyra\n * @dev Modified synthetix SafeDecimalMath to include internal arithmetic underflow/overflow.\n * @dev https://docs.synthetix.io/contracts/source/libraries/SafeDecimalMath/\n */\n\nlibrary DecimalMath {\n  /* Number of decimal places in the representations. */\n  uint8 public constant decimals = 18;\n  uint8 public constant highPrecisionDecimals = 27;\n\n  /* The number representing 1.0. */\n  uint public constant UNIT = 10 ** uint(decimals);\n\n  /* The number representing 1.0 for higher fidelity numbers. */\n  uint public constant PRECISE_UNIT = 10 ** uint(highPrecisionDecimals);\n  uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10 ** uint(highPrecisionDecimals - decimals);\n\n  /**\n   * @return Provides an interface to UNIT.\n   */\n  function unit() external pure returns (uint) {\n    return UNIT;\n  }\n\n  /**\n   * @return Provides an interface to PRECISE_UNIT.\n   */\n  function preciseUnit() external pure returns (uint) {\n    return PRECISE_UNIT;\n  }\n\n  /**\n   * @return The result of multiplying x and y, interpreting the operands as fixed-point\n   * decimals.\n   *\n   * @dev A unit factor is divided out after the product of x and y is evaluated,\n   * so that product must be less than 2**256. As this is an integer division,\n   * the internal division always rounds down. This helps save on gas. Rounding\n   * is more expensive on gas.\n   */\n  function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\n    return (x * y) / UNIT;\n  }\n\n  /**\n   * @return The result of safely multiplying x and y, interpreting the operands\n   * as fixed-point decimals of the specified precision unit.\n   *\n   * @dev The operands should be in the form of a the specified unit factor which will be\n   * divided out after the product of x and y is evaluated, so that product must be\n   * less than 2**256.\n   *\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\n   * (eg. small fractions or percentages).\n   */\n  function _multiplyDecimalRound(uint x, uint y, uint precisionUnit) private pure returns (uint) {\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\n    uint quotientTimesTen = (x * y) / (precisionUnit / 10);\n\n    if (quotientTimesTen % 10 >= 5) {\n      quotientTimesTen += 10;\n    }\n\n    return quotientTimesTen / 10;\n  }\n\n  /**\n   * @return The result of safely multiplying x and y, interpreting the operands\n   * as fixed-point decimals of a precise unit.\n   *\n   * @dev The operands should be in the precise unit factor which will be\n   * divided out after the product of x and y is evaluated, so that product must be\n   * less than 2**256.\n   *\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\n   * (eg. small fractions or percentages).\n   */\n  function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n    return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n  }\n\n  /**\n   * @return The result of safely multiplying x and y, interpreting the operands\n   * as fixed-point decimals of a standard unit.\n   *\n   * @dev The operands should be in the standard unit factor which will be\n   * divided out after the product of x and y is evaluated, so that product must be\n   * less than 2**256.\n   *\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\n   * (eg. small fractions or percentages).\n   */\n  function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n    return _multiplyDecimalRound(x, y, UNIT);\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is a high\n   * precision decimal.\n   *\n   * @dev y is divided after the product of x and the standard precision unit\n   * is evaluated, so the product of x and UNIT must be less than 2**256. As\n   * this is an integer division, the result is always rounded down.\n   * This helps save on gas. Rounding is more expensive on gas.\n   */\n  function divideDecimal(uint x, uint y) internal pure returns (uint) {\n    /* Reintroduce the UNIT factor that will be divided out by y. */\n    return (x * UNIT) / y;\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is as a rounded\n   * decimal in the precision unit specified in the parameter.\n   *\n   * @dev y is divided after the product of x and the specified precision unit\n   * is evaluated, so the product of x and the specified precision unit must\n   * be less than 2**256. The result is rounded to the nearest increment.\n   */\n  function _divideDecimalRound(uint x, uint y, uint precisionUnit) private pure returns (uint) {\n    uint resultTimesTen = (x * (precisionUnit * 10)) / y;\n\n    if (resultTimesTen % 10 >= 5) {\n      resultTimesTen += 10;\n    }\n\n    return resultTimesTen / 10;\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is as a rounded\n   * standard precision decimal.\n   *\n   * @dev y is divided after the product of x and the standard precision unit\n   * is evaluated, so the product of x and the standard precision unit must\n   * be less than 2**256. The result is rounded to the nearest increment.\n   */\n  function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n    return _divideDecimalRound(x, y, UNIT);\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is as a rounded\n   * high precision decimal.\n   *\n   * @dev y is divided after the product of x and the high precision unit\n   * is evaluated, so the product of x and the high precision unit must\n   * be less than 2**256. The result is rounded to the nearest increment.\n   */\n  function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n    return _divideDecimalRound(x, y, PRECISE_UNIT);\n  }\n\n  /**\n   * @dev Convert a standard decimal representation to a high precision one.\n   */\n  function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n    return i * UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR;\n  }\n\n  /**\n   * @dev Convert a high precision decimal to a standard decimal representation.\n   */\n  function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n    uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n    if (quotientTimesTen % 10 >= 5) {\n      quotientTimesTen += 10;\n    }\n\n    return quotientTimesTen / 10;\n  }\n}\n"
    },
    {
      "fileName": "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    {
      "fileName": "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    {
      "fileName": "lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    {
      "fileName": "lib/openzeppelin-contracts/contracts/access/Ownable.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    {
      "fileName": "lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n}\n"
    },
    {
      "fileName": "lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    {
      "fileName": "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    {
      "fileName": "lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    {
      "fileName": "lib/openzeppelin-contracts/contracts/utils/math/Math.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    {
      "fileName": "lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    {
      "fileName": "lib/openzeppelin-contracts/contracts/utils/Context.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    {
      "fileName": "src/risk-managers/BaseManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport \"openzeppelin/access/Ownable2Step.sol\";\nimport \"openzeppelin/utils/math/SafeCast.sol\";\nimport \"openzeppelin/utils/math/Math.sol\";\nimport \"lyra-utils/decimals/DecimalMath.sol\";\nimport \"lyra-utils/decimals/SignedDecimalMath.sol\";\nimport \"lyra-utils/encoding/OptionEncoding.sol\";\n\nimport {ISubAccounts} from \"../interfaces/ISubAccounts.sol\";\nimport {IOptionAsset} from \"../interfaces/IOptionAsset.sol\";\nimport {IPerpAsset} from \"../interfaces/IPerpAsset.sol\";\nimport {ICashAsset} from \"../interfaces/ICashAsset.sol\";\nimport {IForwardFeed} from \"../interfaces/IForwardFeed.sol\";\nimport {IBaseManager} from \"../interfaces/IBaseManager.sol\";\n\nimport {IGlobalSubIdOITracking} from \"../interfaces/IGlobalSubIdOITracking.sol\";\nimport {IDataReceiver} from \"../interfaces/IDataReceiver.sol\";\n\nimport {IForwardFeed} from \"../interfaces/IForwardFeed.sol\";\nimport {IAsset} from \"../interfaces/IAsset.sol\";\nimport {IDutchAuction} from \"../interfaces/IDutchAuction.sol\";\nimport {IManager} from \"../interfaces/IManager.sol\";\nimport {IBasePortfolioViewer} from \"../interfaces/IBasePortfolioViewer.sol\";\n\n/**\n * @title BaseManager\n * @notice Base contract for all managers. Handles OI fee, settling, liquidations and other utility functions.\n */\nabstract contract BaseManager is IBaseManager, Ownable2Step {\n  using DecimalMath for uint;\n  using SignedDecimalMath for int;\n  using SafeCast for uint;\n\n  /// @dev Account contract address\n  ISubAccounts public immutable subAccounts;\n\n  /// @dev Cash asset address\n  ICashAsset public immutable cashAsset;\n\n  /// @dev Dutch auction contract address, can trigger execute bid\n  IDutchAuction public liquidation;\n\n  //////////////////////////\n  //      Variables       //\n  //////////////////////////\n\n  /// @dev Portfolio viewer contract\n  IBasePortfolioViewer public viewer;\n\n  /// @dev the accountId controlled by this manager as intermediate to pay cash if needed\n  uint public immutable accId;\n\n  /// @dev Must be set to a value that the deployment environment can handle the gas cost of the given size.\n  uint public maxAccountSize = 128;\n\n  /// @dev account id that receive OI fee\n  uint public feeRecipientAcc;\n\n  /// @dev The address of guardian, which can pause and unpause adjustments\n  address public guardian;\n\n  /**\n   * @dev If enabled, blocks \"handleAdjustment\" calls. Note, this does not pause manager adjustments such as\n   * liquidations or settlement. This does however block withdrawals, so funds held in the manager cannot exit.\n   */\n  bool public adjustmentsPaused;\n\n  /// @dev minimum OI fee charged, given fee is > 0.\n  uint public minOIFee = 0;\n\n  /// @dev mapping of tradeId => accountId => fee charged\n  mapping(uint => mapping(uint => uint)) public feeCharged;\n\n  /// @dev keep track of the last tradeId that this manager updated before, to prevent double update\n  uint internal lastOracleUpdateTradeId;\n\n  /// @dev tx msg.sender to Accounts that can bypass OI fee on perp or options\n  mapping(address sender => bool) public feeBypassedCaller;\n\n  mapping(address callee => bool) internal whitelistedCallee;\n\n  mapping(address => bool) public trustedRiskAssessor;\n\n  constructor(\n    ISubAccounts _subAccounts,\n    ICashAsset _cashAsset,\n    IDutchAuction _liquidation,\n    IBasePortfolioViewer _viewer\n  ) Ownable2Step() {\n    subAccounts = _subAccounts;\n    cashAsset = _cashAsset;\n    liquidation = _liquidation;\n    viewer = _viewer;\n\n    accId = subAccounts.createAccount(address(this), IManager(address(this)));\n  }\n\n  //////////////////////////\n  // Owner-only Functions //\n  //////////////////////////\n\n  function setLiquidation(IDutchAuction _liquidation) external onlyOwner {\n    if (address(_liquidation) == address(0)) revert BM_InvalidLiquidation();\n    liquidation = _liquidation;\n    emit LiquidationSet(address(_liquidation));\n  }\n\n  /**\n   * @dev Governance determined account to receive OI fee\n   * @param _newAcc account id\n   */\n  function setFeeRecipient(uint _newAcc) external onlyOwner {\n    // this line will revert if the owner tries to set an invalid account\n    subAccounts.ownerOf(_newAcc);\n\n    feeRecipientAcc = _newAcc;\n    emit FeeRecipientSet(_newAcc);\n  }\n\n  function setMinOIFee(uint newMinOIFee) external onlyOwner {\n    if (newMinOIFee > 10000e18) {\n      revert BM_MinOIFeeTooHigh();\n    }\n    minOIFee = newMinOIFee;\n\n    emit MinOIFeeSet(minOIFee);\n  }\n\n  /**\n   * @notice Governance determined tx msg.sender to Accounts that can bypass OI fee on perp or options\n   * @param caller msg.sender to Accounts, caller reported by handleAdjustment\n   * @param bypassed true to bypass OI fee, false to charge OI fee\n   */\n  function setFeeBypassedCaller(address caller, bool bypassed) external onlyOwner {\n    feeBypassedCaller[caller] = bypassed;\n\n    emit FeeBypassedCallerSet(caller, bypassed);\n  }\n\n  /**\n   * @notice Governance determined whitelist that can be called during processManagerData\n   */\n  function setWhitelistedCallee(address callee, bool whitelisted) external onlyOwner {\n    whitelistedCallee[callee] = whitelisted;\n\n    emit CalleeWhitelisted(callee);\n  }\n\n  /**\n   * @dev set max amount of assets in a single account\n   */\n  function setMaxAccountSize(uint _maxAccountSize) external onlyOwner {\n    if (_maxAccountSize < 8 || _maxAccountSize > 500) {\n      revert BM_InvalidMaxAccountSize();\n    }\n    maxAccountSize = _maxAccountSize;\n    emit MaxAccountSizeUpdated(_maxAccountSize);\n  }\n\n  function setTrustedRiskAssessor(address riskAssessor, bool trusted) external onlyOwner {\n    trustedRiskAssessor[riskAssessor] = trusted;\n    emit TrustedRiskAssessorUpdated(riskAssessor, trusted);\n  }\n\n  function setGuardian(address _guardian) external onlyOwner {\n    guardian = _guardian;\n    emit GuardianSet(_guardian);\n  }\n\n  function setAdjustmentsPaused(bool _paused) external {\n    if (msg.sender != guardian) revert BM_GuardianOnly();\n    adjustmentsPaused = _paused;\n    emit AdjustmentsPausedSet(_paused);\n  }\n\n  //////////////////////\n  //   Liquidations   //\n  //////////////////////\n\n  /**\n   * @notice Transfers portion of account to the liquidator.\n   *         Transfers cash to the liquidated account.\n   * @dev Auction contract can decide to either:\n   *      - revert / process bid\n   *      - continue / complete auction\n   * @param accountId ID of account which is being liquidated. assumed to be controlled by this manager\n   * @param liquidatorId Liquidator account ID. assumed to be controlled by this manager\n   * @param portion Portion of account that is requested to be liquidated.\n   * @param bidAmount Cash amount liquidator is offering for portion of account.\n   * @param reservedCash Cash amount to ignore in liquidated account's balance.\n   */\n  function executeBid(uint accountId, uint liquidatorId, uint portion, uint bidAmount, uint reservedCash)\n    external\n    onlyLiquidations\n  {\n    if (portion > 1e18) revert BM_InvalidBidPortion();\n\n    ISubAccounts.AssetBalance[] memory assetBalances = subAccounts.getAccountBalances(accountId);\n\n    // transfer liquidated account's asset to liquidator\n    for (uint i; i < assetBalances.length; i++) {\n      int ignoreAmount = 0;\n      if (assetBalances[i].asset == cashAsset) {\n        ignoreAmount = reservedCash.toInt256();\n      }\n\n      _symmetricManagerAdjustment(\n        accountId,\n        liquidatorId,\n        assetBalances[i].asset,\n        uint96(assetBalances[i].subId),\n        (assetBalances[i].balance - ignoreAmount).multiplyDecimal(int(portion))\n      );\n    }\n\n    if (bidAmount != 0) {\n      // transfer cash (bid amount) to liquidated account\n      _symmetricManagerAdjustment(liquidatorId, accountId, cashAsset, 0, int(bidAmount));\n    }\n  }\n\n  /**\n   * @dev the liquidation module can request manager to pay the liquidation fee from liquidated account at start of auction\n   * @param accountId Account paying the fee (liquidated)\n   * @param recipient Account receiving the fee, may NOT be controlled by this manager\n   */\n  function payLiquidationFee(uint accountId, uint recipient, uint cashAmount) external onlyLiquidations {\n    _transferCash(accountId, recipient, cashAmount.toInt256());\n  }\n\n  /**\n   * @dev settle pending interest on an account\n   * @param accountId account id\n   */\n  function settleInterest(uint accountId) external {\n    subAccounts.managerAdjustment(ISubAccounts.AssetAdjustment(accountId, cashAsset, 0, 0, bytes32(0)));\n  }\n\n  //////////////////////////\n  //  Internal Functions  //\n  //////////////////////////\n\n  function _preAdjustmentHooks(\n    uint accountId,\n    uint tradeId,\n    address caller,\n    ISubAccounts.AssetDelta[] memory assetDeltas,\n    bytes calldata managerData\n  ) internal {\n    if (adjustmentsPaused) revert BM_AdjustmentsPaused();\n    _processManagerData(tradeId, managerData);\n    viewer.checkAllAssetCaps(IManager(this), accountId, tradeId);\n    _chargeAllOIFee(caller, accountId, tradeId, assetDeltas);\n  }\n\n  function _chargeAllOIFee(\n    address, /*caller*/\n    uint, /*accountId*/\n    uint, /*tradeId*/\n    ISubAccounts.AssetDelta[] memory /*assetDeltas*/\n  ) internal virtual {\n    // Each manager must implement their own logic to charge OI fee\n    revert BM_NotImplemented();\n  }\n\n  /**\n   * @dev send custom data to oracles. Oracles should implement the verification logic on their own\n   */\n  function _processManagerData(uint tradeId, bytes calldata managerData) internal {\n    if (managerData.length == 0 || lastOracleUpdateTradeId == tradeId) return;\n\n    lastOracleUpdateTradeId = tradeId;\n\n    // parse array of data and update each oracle or take action\n    ManagerData[] memory managerDatas = abi.decode(managerData, (ManagerData[]));\n    for (uint i; i < managerDatas.length; i++) {\n      // invoke some actions if needed\n      if (!whitelistedCallee[managerDatas[i].receiver]) revert BM_UnauthorizedCall();\n      IDataReceiver(managerDatas[i].receiver).acceptData(managerDatas[i].data);\n    }\n  }\n\n  function _checkIfLiveAuction(uint accountId) internal view {\n    if (liquidation.isAuctionLive(accountId)) {\n      revert BM_AccountUnderLiquidation();\n    }\n  }\n\n  ////////////////\n  //   OI Fee   //\n  ////////////////\n\n  /**\n   * @dev calculate the option OI fee for a specific option + subId combination\n   * @dev if the OI after a batched trade is increased, all participants will be charged a fee if he trades this asset\n   * @param asset Option contract\n   * @param forwardFeed Forward feed contract\n   * @param delta Change in this trade\n   * @param subId SubId of the option\n   */\n  function _getOptionOIFee(IGlobalSubIdOITracking asset, IForwardFeed forwardFeed, int delta, uint subId, uint tradeId)\n    internal\n    view\n    returns (uint fee)\n  {\n    (uint expiry,,) = OptionEncoding.fromSubId(subId.toUint96());\n    (uint forwardPrice,) = forwardFeed.getForwardPrice(uint64(expiry));\n    fee = viewer.getAssetOIFee(asset, subId, delta, tradeId, forwardPrice);\n  }\n\n  /**\n   * @notice calculate the perpetual OI fee.\n   * @dev if the OI after a batched trade is increased, all participants will be charged a fee if he trades this asset\n   */\n  function _getPerpOIFee(IPerpAsset perpAsset, int delta, uint tradeId) internal view returns (uint fee) {\n    (uint perpPrice,) = perpAsset.getPerpPrice();\n    fee = viewer.getAssetOIFee(perpAsset, 0, delta, tradeId, perpPrice);\n  }\n\n  /**\n   * @dev Pay fee, carry up to minFee\n   */\n  function _payFee(uint accountId, uint fee) internal {\n    // Only consider min fee if expected fee is > 0\n    if (fee == 0 || feeRecipientAcc == 0) return;\n\n    // transfer cash to fee recipient account\n    _symmetricManagerAdjustment(accountId, feeRecipientAcc, cashAsset, 0, int(Math.max(fee, minOIFee)));\n  }\n\n  //////////////////////////\n  //     Settlement       //\n  //////////////////////////\n\n  /**\n   * @dev settle an account by removing all expired option positions and adjust cash balance\n   * @dev this function will not revert even if settlement price is not updated\n   * @param accountId Account Id to settle\n   */\n  function _settleAccountOptions(IOptionAsset option, uint accountId) internal {\n    ISubAccounts.AssetBalance[] memory balances = subAccounts.getAccountBalances(accountId);\n    int cashDelta = 0;\n    for (uint i; i < balances.length; i++) {\n      // skip non option asset\n      if (balances[i].asset != option) continue;\n\n      (int value, bool isSettled) = option.calcSettlementValue(balances[i].subId, balances[i].balance);\n      if (!isSettled) continue;\n\n      cashDelta += value;\n\n      // update user option balance\n      subAccounts.managerAdjustment(\n        ISubAccounts.AssetAdjustment(accountId, option, balances[i].subId, -(balances[i].balance), bytes32(0))\n      );\n\n      emit OptionSettled(accountId, address(option), balances[i].subId, balances[i].balance, value);\n    }\n\n    // update user cash amount\n    subAccounts.managerAdjustment(ISubAccounts.AssetAdjustment(accountId, cashAsset, 0, cashDelta, bytes32(0)));\n    // report total print / burn to cash asset\n    cashAsset.updateSettledCash(cashDelta);\n  }\n\n  /**\n   * @notice to settle an account, clear PNL and funding in the perp contract and pay out cash\n   * @dev this should only be called after a perp transfer happens on this account\n   */\n  function _settlePerpRealizedPNL(IPerpAsset perp, uint accountId) internal {\n    // settle perp: update latest funding rate and settle\n    (int pnl, int funding) = perp.settleRealizedPNLAndFunding(accountId);\n\n    int netCash = pnl + funding;\n\n    emit PerpSettled(accountId, address(perp), pnl, funding);\n\n    if (netCash == 0) return;\n\n    cashAsset.updateSettledCash(netCash);\n\n    // update user cash amount\n    subAccounts.managerAdjustment(ISubAccounts.AssetAdjustment(accountId, cashAsset, 0, netCash, bytes32(0)));\n  }\n\n  /**\n   * @notice settle account's perp position with index price, and settle through cash\n   * @dev calling function should make sure perp address is trusted\n   */\n  function _settlePerpUnrealizedPNL(IPerpAsset perp, uint accountId) internal {\n    perp.realizeAccountPNL(accountId);\n\n    _settlePerpRealizedPNL(perp, accountId);\n  }\n\n  /**\n   * @dev transfer asset from one account to another without invoking manager hook\n   * @param from Account id of the from account. Must be controlled by this manager\n   * @param to Account id of the to account. Must be controlled by this manager\n   * @param asset Asset address to transfer\n   * @param subId Asset subId to transfer\n   * @param amount Amount of asset to transfer\n   */\n  function _symmetricManagerAdjustment(uint from, uint to, IAsset asset, uint96 subId, int amount) internal {\n    // deduct amount in from account\n    subAccounts.managerAdjustment(\n      ISubAccounts.AssetAdjustment({acc: from, asset: asset, subId: subId, amount: -amount, assetData: bytes32(0)})\n    );\n\n    // increase \"to\" account\n    subAccounts.managerAdjustment(\n      ISubAccounts.AssetAdjustment({acc: to, asset: asset, subId: subId, amount: amount, assetData: bytes32(0)})\n    );\n  }\n\n  /**\n   * @dev transfer asset from one account to another without invoking manager hook\n   * @param from Account id of the from account. Must be controlled by this manager\n   * @param to Account id of the to account. May not be controlled by this manager\n   */\n  function _transferCash(uint from, uint to, int amount) internal {\n    // deduct amount in from account\n    subAccounts.managerAdjustment(\n      ISubAccounts.AssetAdjustment({acc: from, asset: cashAsset, subId: 0, amount: -amount, assetData: bytes32(0)})\n    );\n\n    // check if recipient under the same manager\n    if (address(subAccounts.manager(to)) == address(this)) {\n      // increase to account balance directly\n      subAccounts.managerAdjustment(\n        ISubAccounts.AssetAdjustment({acc: to, asset: cashAsset, subId: 0, amount: amount, assetData: bytes32(0)})\n      );\n    } else {\n      // mint cash to this account\n      subAccounts.managerAdjustment(\n        ISubAccounts.AssetAdjustment({acc: accId, asset: cashAsset, subId: 0, amount: amount, assetData: bytes32(0)})\n      );\n      subAccounts.submitTransfer(\n        ISubAccounts.AssetTransfer({\n          fromAcc: accId,\n          toAcc: to,\n          asset: cashAsset,\n          subId: 0,\n          amount: amount,\n          assetData: \"\"\n        }),\n        \"\"\n      );\n    }\n  }\n\n  /////////////////////\n  //    Modifier     //\n  /////////////////////\n\n  modifier onlyLiquidations() {\n    if (msg.sender != address(liquidation)) revert BM_OnlyLiquidationModule();\n    _;\n  }\n\n  modifier onlyAccounts() {\n    if (msg.sender != address(subAccounts)) revert BM_OnlyAccounts();\n    _;\n  }\n}\n"
    },
    {
      "fileName": "src/risk-managers/PMRM.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport \"openzeppelin/utils/math/SafeCast.sol\";\nimport \"openzeppelin/utils/math/Math.sol\";\nimport \"openzeppelin/utils/math/SignedMath.sol\";\nimport \"openzeppelin/security/ReentrancyGuard.sol\";\n\nimport \"lyra-utils/encoding/OptionEncoding.sol\";\nimport \"lyra-utils/decimals/DecimalMath.sol\";\nimport \"lyra-utils/decimals/SignedDecimalMath.sol\";\n\nimport {IManager} from \"../interfaces/IManager.sol\";\nimport {ISubAccounts} from \"../interfaces/ISubAccounts.sol\";\nimport {ICashAsset} from \"../interfaces/ICashAsset.sol\";\nimport {IPerpAsset} from \"../interfaces/IPerpAsset.sol\";\nimport {IPMRMLib} from \"../interfaces/IPMRMLib.sol\";\nimport {IOptionAsset} from \"../interfaces/IOptionAsset.sol\";\nimport {ISpotFeed} from \"../interfaces/ISpotFeed.sol\";\nimport {ILiquidatableManager} from \"../interfaces/ILiquidatableManager.sol\";\nimport {IVolFeed} from \"../interfaces/IVolFeed.sol\";\nimport {IInterestRateFeed} from \"../interfaces/IInterestRateFeed.sol\";\nimport {IPMRM} from \"../interfaces/IPMRM.sol\";\nimport {IWrappedERC20Asset} from \"../interfaces/IWrappedERC20Asset.sol\";\nimport {IDutchAuction} from \"../interfaces/IDutchAuction.sol\";\nimport {IForwardFeed} from \"../interfaces/IForwardFeed.sol\";\nimport {IBasePortfolioViewer} from \"../interfaces/IBasePortfolioViewer.sol\";\n\nimport {BaseManager} from \"./BaseManager.sol\";\n\n/**\n * @title PMRM\n * @author Lyra\n * @notice Risk Manager that uses a SPAN like methodology to margin an options portfolio.\n */\n\ncontract PMRM is IPMRM, ILiquidatableManager, BaseManager, ReentrancyGuard {\n  using SignedDecimalMath for int;\n  using DecimalMath for uint;\n  using SafeCast for uint;\n  using SafeCast for int;\n\n  IOptionAsset public immutable option;\n  IPerpAsset public immutable perp;\n  IWrappedERC20Asset public immutable baseAsset;\n\n  /////////////////\n  //  Variables  //\n  /////////////////\n\n  ISpotFeed public spotFeed;\n  IInterestRateFeed public interestRateFeed;\n  IVolFeed public volFeed;\n  ISpotFeed public stableFeed;\n  IForwardFeed public forwardFeed;\n\n  /// @dev lib contract\n  IPMRMLib public immutable lib;\n\n  /// @dev Value to help optimise the arranging of portfolio. Should be minimised if possible.\n  uint public maxExpiries = 11;\n\n  IPMRM.Scenario[] internal marginScenarios;\n\n  ////////////////////////\n  //    Constructor     //\n  ////////////////////////\n\n  constructor(\n    ISubAccounts subAccounts_,\n    ICashAsset cashAsset_,\n    IOptionAsset option_,\n    IPerpAsset perp_,\n    IWrappedERC20Asset baseAsset_,\n    IDutchAuction liquidation_,\n    Feeds memory feeds_,\n    IBasePortfolioViewer viewer_,\n    IPMRMLib lib_\n  ) BaseManager(subAccounts_, cashAsset_, liquidation_, viewer_) {\n    spotFeed = feeds_.spotFeed;\n    stableFeed = feeds_.stableFeed;\n    forwardFeed = feeds_.forwardFeed;\n    interestRateFeed = feeds_.interestRateFeed;\n    volFeed = feeds_.volFeed;\n    lib = lib_;\n\n    baseAsset = baseAsset_;\n    option = option_;\n    perp = perp_;\n  }\n\n  /////////////////////\n  //   Owner-only    //\n  /////////////////////\n\n  /**\n   * @dev set max tradeable expiries in a single account\n   */\n  function setMaxExpiries(uint _maxExpiries) external onlyOwner {\n    if (_maxExpiries <= maxExpiries || _maxExpiries > 30) {\n      revert PMRM_InvalidMaxExpiries();\n    }\n    maxExpiries = _maxExpiries;\n    emit MaxExpiriesUpdated(_maxExpiries);\n  }\n\n  function setInterestRateFeed(IInterestRateFeed _interestRateFeed) external onlyOwner {\n    interestRateFeed = _interestRateFeed;\n    emit InterestRateFeedUpdated(_interestRateFeed);\n  }\n\n  function setVolFeed(IVolFeed _volFeed) external onlyOwner {\n    volFeed = _volFeed;\n    emit VolFeedUpdated(_volFeed);\n  }\n\n  function setSpotFeed(ISpotFeed _spotFeed) external onlyOwner {\n    spotFeed = _spotFeed;\n    emit SpotFeedUpdated(_spotFeed);\n  }\n\n  function setStableFeed(ISpotFeed _stableFeed) external onlyOwner {\n    stableFeed = _stableFeed;\n    emit StableFeedUpdated(_stableFeed);\n  }\n\n  function setForwardFeed(IForwardFeed _forwardFeed) external onlyOwner {\n    forwardFeed = _forwardFeed;\n    emit ForwardFeedUpdated(_forwardFeed);\n  }\n\n  /**\n   * @notice Sets the scenarios for managing margin positions.\n   * @dev Only the contract owner can invoke this function.\n   * @param _scenarios An array of Scenario structs representing the margin scenarios.\n   *                   Each Scenario struct contains relevant data for a specific scenario.\n   */\n  function setScenarios(IPMRM.Scenario[] memory _scenarios) external onlyOwner {\n    if (_scenarios.length == 0 || _scenarios.length > 40) {\n      revert PMRM_InvalidScenarios();\n    }\n    for (uint i = 0; i < _scenarios.length; i++) {\n      if (_scenarios[i].spotShock > 3e18) {\n        revert PMRM_InvalidSpotShock();\n      }\n      if (marginScenarios.length <= i) {\n        marginScenarios.push(_scenarios[i]);\n      } else {\n        marginScenarios[i] = _scenarios[i];\n      }\n    }\n\n    uint marginScenariosLength = marginScenarios.length;\n    for (uint i = _scenarios.length; i < marginScenariosLength; i++) {\n      marginScenarios.pop();\n    }\n    emit ScenariosUpdated(_scenarios);\n  }\n\n  ///////////////////////\n  //   Account Hooks   //\n  ///////////////////////\n\n  /**\n   * @notice Handles adjustments to the margin positions for a given account.\n   * @dev Only the accounts contract can invoke this function.\n   * @param accountId The ID of the account.\n   * @param tradeId The ID of the trade.\n   * @param caller The address of the caller.\n   * @param assetDeltas An array of AssetDelta structs representing changes to account assets.\n   * @param managerData Additional data (unused in this function).\n   */\n  function handleAdjustment(\n    uint accountId,\n    uint tradeId,\n    address caller,\n    ISubAccounts.AssetDelta[] memory assetDeltas,\n    bytes calldata managerData\n  ) external onlyAccounts nonReentrant {\n    _preAdjustmentHooks(accountId, tradeId, caller, assetDeltas, managerData);\n\n    // Block any transfers where an account is under liquidation\n    _checkIfLiveAuction(accountId);\n\n    bool riskAdding = false;\n    for (uint i = 0; i < assetDeltas.length; i++) {\n      if (assetDeltas[i].asset == perp) {\n        // Settle perp PNL into cash if the user traded perp in this tx.\n        _settlePerpRealizedPNL(perp, accountId);\n        riskAdding = true;\n      } else if (\n        assetDeltas[i].asset != cashAsset && assetDeltas[i].asset != option && assetDeltas[i].asset != baseAsset\n      ) {\n        revert PMRM_UnsupportedAsset();\n      } else {\n        if (assetDeltas[i].delta < 0) {\n          riskAdding = true;\n        }\n      }\n    }\n\n    ISubAccounts.AssetBalance[] memory assetBalances = subAccounts.getAccountBalances(accountId);\n\n    if (\n      assetBalances.length > maxAccountSize //\n        && viewer.getPreviousAssetsLength(assetBalances, assetDeltas) < assetBalances.length\n    ) {\n      revert PMRM_TooManyAssets();\n    }\n\n    if (!riskAdding) {\n      // Early exit if only adding cash/option/baseAsset\n      return;\n    }\n    _assessRisk(caller, accountId, assetBalances);\n  }\n\n  ///////////////////////\n  // Arrange Portfolio //\n  ///////////////////////\n\n  function _assessRisk(address caller, uint accountId, ISubAccounts.AssetBalance[] memory assetBalances) internal view {\n    IPMRM.Portfolio memory portfolio = _arrangePortfolio(accountId, assetBalances);\n\n    if (trustedRiskAssessor[caller]) {\n      // If the caller is a trusted risk assessor, only use the basis contingency scenarios (3 scenarios)\n      (int atmMM,,) = lib.getMarginAndMarkToMarket(portfolio, false, lib.getBasisContingencyScenarios());\n      if (atmMM >= 0) return;\n    } else {\n      // If the caller is not a trusted risk assessor, use all the margin scenarios\n      (int postIM,,) = lib.getMarginAndMarkToMarket(portfolio, true, marginScenarios);\n      if (postIM >= 0) return;\n    }\n    revert PMRM_InsufficientMargin();\n  }\n\n  /**\n   * @notice Arrange portfolio into cash + arranged\n   *         array of [strikes][calls / puts / forwards].\n   * @param assets Array of balances for given asset and subId.\n   * @return portfolio Cash + option holdings.\n   */\n  function _arrangePortfolio(uint accountId, ISubAccounts.AssetBalance[] memory assets)\n    internal\n    view\n    returns (IPMRM.Portfolio memory portfolio)\n  {\n    (uint seenExpiries, PortfolioExpiryData[] memory expiryCount) = _countExpiriesAndOptions(assets);\n\n    portfolio.expiries = new ExpiryHoldings[](seenExpiries);\n    (portfolio.spotPrice, portfolio.minConfidence) = spotFeed.getSpot();\n    (uint stablePrice,) = stableFeed.getSpot();\n    portfolio.stablePrice = stablePrice;\n\n    _initialiseExpiries(portfolio, expiryCount);\n    _arrangeOptions(accountId, portfolio, assets, expiryCount);\n\n    if (portfolio.perpPosition != 0) {\n      (uint perpPrice, uint perpConfidence) = perp.getPerpPrice();\n      portfolio.perpPrice = perpPrice;\n      portfolio.minConfidence = Math.min(portfolio.minConfidence, perpConfidence);\n    }\n\n    portfolio = lib.addPrecomputes(portfolio);\n\n    return portfolio;\n  }\n\n  function _countExpiriesAndOptions(ISubAccounts.AssetBalance[] memory assets)\n    internal\n    view\n    returns (uint seenExpiries, IPMRM.PortfolioExpiryData[] memory expiryCount)\n  {\n    uint assetLen = assets.length;\n\n    seenExpiries = 0;\n    expiryCount = new IPMRM.PortfolioExpiryData[](maxExpiries > assetLen ? assetLen : maxExpiries);\n\n    // Just count the number of options per expiry\n    for (uint i = 0; i < assetLen; ++i) {\n      ISubAccounts.AssetBalance memory currentAsset = assets[i];\n      if (address(currentAsset.asset) == address(option)) {\n        (uint optionExpiry,,) = OptionEncoding.fromSubId(currentAsset.subId.toUint96());\n\n        bool found = false;\n        for (uint j = 0; j < seenExpiries; j++) {\n          if (expiryCount[j].expiry == optionExpiry) {\n            expiryCount[j].optionCount++;\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          if (seenExpiries == maxExpiries) {\n            revert PMRM_TooManyExpiries();\n          }\n          expiryCount[seenExpiries++] = PortfolioExpiryData({expiry: uint64(optionExpiry), optionCount: 1});\n        }\n      }\n    }\n\n    return (seenExpiries, expiryCount);\n  }\n\n  /**\n   * @dev initial array of empty ExpiryHolding structs in the portfolio struct\n   */\n  function _initialiseExpiries(IPMRM.Portfolio memory portfolio, PortfolioExpiryData[] memory expiryCount)\n    internal\n    view\n  {\n    for (uint i = 0; i < portfolio.expiries.length; ++i) {\n      (uint forwardFixedPortion, uint forwardVariablePortion, uint fwdConfidence) =\n        forwardFeed.getForwardPricePortions(expiryCount[i].expiry);\n      (int rate, uint rateConfidence) = interestRateFeed.getInterestRate(expiryCount[i].expiry);\n      // We dont compare this to the portfolio.minConfidence yet - we do that in preComputes\n      uint minConfidence = Math.min(fwdConfidence, rateConfidence);\n\n      // if an option expired, also set secToExpiry to 0\n      uint64 secToExpiry =\n        expiryCount[i].expiry > uint64(block.timestamp) ? uint64(expiryCount[i].expiry - block.timestamp) : 0;\n      portfolio.expiries[i] = ExpiryHoldings({\n        expiry: expiryCount[i].expiry,\n        secToExpiry: secToExpiry,\n        options: new StrikeHolding[](expiryCount[i].optionCount),\n        forwardFixedPortion: forwardFixedPortion,\n        forwardVariablePortion: forwardVariablePortion,\n        // We assume the rate is always positive\n        rate: SignedMath.max(0, rate).toUint256(),\n        minConfidence: minConfidence,\n        netOptions: 0,\n        // vol shocks are added in addPrecomputes\n        mtm: 0,\n        basisScenarioUpMtM: 0,\n        basisScenarioDownMtM: 0,\n        volShockUp: 0,\n        volShockDown: 0,\n        staticDiscount: 0\n      });\n    }\n  }\n\n  function _arrangeOptions(\n    uint accountId,\n    IPMRM.Portfolio memory portfolio,\n    ISubAccounts.AssetBalance[] memory assets,\n    PortfolioExpiryData[] memory expiryCount\n  ) internal view {\n    for (uint i = 0; i < assets.length; ++i) {\n      ISubAccounts.AssetBalance memory currentAsset = assets[i];\n      if (address(currentAsset.asset) == address(option)) {\n        (uint optionExpiry, uint strike, bool isCall) = OptionEncoding.fromSubId(currentAsset.subId.toUint96());\n\n        uint expiryIndex = findInArray(portfolio.expiries, optionExpiry, portfolio.expiries.length);\n\n        ExpiryHoldings memory expiry = portfolio.expiries[expiryIndex];\n\n        (uint vol, uint confidence) = volFeed.getVol(strike.toUint128(), optionExpiry.toUint64());\n\n        expiry.minConfidence = Math.min(confidence, expiry.minConfidence);\n\n        expiry.netOptions += SignedMath.abs(currentAsset.balance);\n\n        uint index = --expiryCount[expiryIndex].optionCount;\n        expiry.options[index] =\n          StrikeHolding({strike: strike, vol: vol, amount: currentAsset.balance, isCall: isCall, seenInFilter: false});\n      } else if (address(currentAsset.asset) == address(cashAsset)) {\n        portfolio.cash = currentAsset.balance;\n      } else if (address(currentAsset.asset) == address(perp)) {\n        portfolio.perpPosition = currentAsset.balance;\n        portfolio.perpValue = perp.getUnsettledAndUnrealizedCash(accountId);\n      } else if (address(currentAsset.asset) == address(baseAsset)) {\n        portfolio.basePosition = currentAsset.balance.toUint256();\n      } // No need to catch other assets, as they will be caught in handleAdjustment\n    }\n  }\n\n  /**\n   * @dev Return index of expiry in the array, revert if not found\n   */\n  function findInArray(ExpiryHoldings[] memory expiryData, uint expiryToFind, uint arrayLen)\n    internal\n    pure\n    returns (uint index)\n  {\n    unchecked {\n      for (uint i; i < arrayLen; ++i) {\n        if (expiryData[i].expiry == expiryToFind) {\n          return i;\n        }\n      }\n      revert PMRM_FindInArrayError();\n    }\n  }\n\n  /**\n   * @dev Iterate through all asset delta, charge OI fee for perp and option assets\n   */\n  function _chargeAllOIFee(address caller, uint accountId, uint tradeId, ISubAccounts.AssetDelta[] memory assetDeltas)\n    internal\n    override\n  {\n    if (feeBypassedCaller[caller]) return;\n\n    uint fee;\n    // iterate through all asset changes, if it's option asset, change if OI increased\n    for (uint i; i < assetDeltas.length; i++) {\n      if (address(assetDeltas[i].asset) == address(option)) {\n        fee += _getOptionOIFee(option, forwardFeed, assetDeltas[i].delta, assetDeltas[i].subId, tradeId);\n      } else if (address(assetDeltas[i].asset) == address(perp)) {\n        fee += _getPerpOIFee(perp, assetDeltas[i].delta, tradeId);\n      }\n    }\n\n    _payFee(accountId, fee);\n  }\n\n  ////////////////\n  //  External  //\n  ////////////////\n\n  /**\n   * @notice Can be called by anyone to settle a perp asset in an account\n   */\n  function settlePerpsWithIndex(uint accountId) external {\n    _settlePerpUnrealizedPNL(perp, accountId);\n  }\n\n  /**\n   * @notice Can be called by anyone to settle a perp asset in an account\n   */\n  function settleOptions(IOptionAsset _option, uint accountId) external {\n    if (_option != option) revert PMRM_UnsupportedAsset();\n    _settleAccountOptions(_option, accountId);\n  }\n\n  ////////////\n  //  View  //\n  ////////////\n\n  /**\n   * @notice Return all scenarios\n   */\n  function getScenarios() external view returns (IPMRM.Scenario[] memory) {\n    return marginScenarios;\n  }\n\n  /**\n   * @notice Turn balance into an arranged portfolio struct\n   */\n  function arrangePortfolio(uint accountId) external view returns (IPMRM.Portfolio memory portfolio) {\n    return _arrangePortfolio(accountId, subAccounts.getAccountBalances(accountId));\n  }\n\n  /**\n   * @notice Get the initial margin or maintenance margin of an account\n   * @dev if the returned value is negative, it means the account is under margin requirement\n   */\n  function getMargin(uint accountId, bool isInitial) external view returns (int) {\n    IPMRM.Portfolio memory portfolio = _arrangePortfolio(accountId, subAccounts.getAccountBalances(accountId));\n    (int margin,,) = lib.getMarginAndMarkToMarket(portfolio, isInitial, marginScenarios);\n    return margin;\n  }\n\n  /**\n   * @notice Get margin level and mark to market of an account\n   */\n  function getMarginAndMarkToMarket(uint accountId, bool isInitial, uint scenarioId)\n    external\n    view\n    returns (int margin, int mtm)\n  {\n    IPMRM.Portfolio memory portfolio = _arrangePortfolio(accountId, subAccounts.getAccountBalances(accountId));\n    IPMRM.Scenario[] memory scenarios = new IPMRM.Scenario[](1);\n\n    scenarios[0] = marginScenarios[scenarioId];\n\n    (margin, mtm,) = lib.getMarginAndMarkToMarket(portfolio, isInitial, scenarios);\n    return (margin, mtm);\n  }\n}\n"
    },
    {
      "fileName": "src/interfaces/IInterestRateModel.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IInterestRateModel {\n  /**\n   * @notice Function to calculate the interest on debt balances\n   *\n   * @param elapsedTime Seconds since last interest accrual\n   * @param borrowRate The current borrow rate for the asset\n   * @return Interest factor accumlated in the elapsedTime\n   */\n  function getBorrowInterestFactor(uint elapsedTime, uint borrowRate) external pure returns (uint);\n\n  /**\n   * @notice Calculates the current borrow rate as a linear equation\n   * @param supply The supplied amount of stablecoin for the asset\n   * @param borrows The amount of borrows in the market\n   * @return The borrow rate percentage as a mantissa\n   */\n  function getBorrowRate(uint supply, uint borrows) external view returns (uint);\n\n  /**\n   * @notice Calculates the utilization rate of the market: `borrows / supply`\n   * @param supply The supplied amount of stablecoin for the asset\n   * @param borrows The amount of borrows for the asset\n   * @return The utilization rate as a mantissa between\n   */\n  function getUtilRate(uint supply, uint borrows) external pure returns (uint);\n\n  ////////////\n  // Events //\n  ////////////\n\n  /// @dev Emitted when interest rate parameters are set\n  event InterestRateParamsSet(uint minRate, uint rateMultiplier, uint highRateMultiplier, uint optimalUtil);\n\n  ////////////\n  // Errors //\n  ////////////\n\n  /// @dev Revert when the parameter set is greater than 1e18\n  error IRM_InvalidParamBound();\n  error IRM_NoElapsedTime(uint elapsedTime);\n}\n"
    },
    {
      "fileName": "src/interfaces/IWrappedERC20Asset.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IERC20BasedAsset} from \"./IERC20BasedAsset.sol\";\nimport {IPositionTracking} from \"./IPositionTracking.sol\";\n\ninterface IWrappedERC20Asset is IERC20BasedAsset, IPositionTracking {\n  //////////////\n  //  Errors  //\n  //////////////\n  error WERC_OnlyAccountOwner();\n  error WERC_CannotBeNegative();\n  error WERC_InvalidSubId();\n}\n"
    },
    {
      "fileName": "src/interfaces/IPMRM.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {ISpotFeed} from \"./ISpotFeed.sol\";\nimport {IForwardFeed} from \"./IForwardFeed.sol\";\nimport {IInterestRateFeed} from \"./IInterestRateFeed.sol\";\nimport {IVolFeed} from \"./IVolFeed.sol\";\n\ninterface IPMRM {\n  enum VolShockDirection {\n    None,\n    Up,\n    Down\n  }\n\n  struct Feeds {\n    ISpotFeed spotFeed;\n    ISpotFeed stableFeed;\n    IForwardFeed forwardFeed;\n    IInterestRateFeed interestRateFeed;\n    IVolFeed volFeed;\n  }\n\n  struct Portfolio {\n    uint spotPrice;\n    uint perpPrice;\n    uint stablePrice;\n    /// cash amount or debt\n    int cash;\n    /// option holdings per expiry\n    ExpiryHoldings[] expiries;\n    int perpPosition;\n    uint basePosition;\n    uint baseValue;\n    int totalMtM;\n    // Calculated values\n    int basisContingency;\n    // option + base + perp; excludes fwd/oracle\n    uint staticContingency;\n    uint confidenceContingency;\n    uint minConfidence;\n    int perpValue;\n  }\n\n  struct ExpiryHoldings {\n    // used as key\n    uint expiry;\n    uint secToExpiry;\n    StrikeHolding[] options;\n    // portion unaffected by spot shocks\n    uint forwardFixedPortion;\n    // portion affected by spot shocks\n    uint forwardVariablePortion;\n    // We always assume the rate is >= 0\n    uint rate;\n    uint minConfidence;\n    uint netOptions;\n    int mtm;\n    int basisScenarioUpMtM;\n    int basisScenarioDownMtM;\n    uint volShockUp;\n    uint volShockDown;\n    uint staticDiscount;\n  }\n\n  struct StrikeHolding {\n    /// strike price of held options\n    uint strike;\n    uint vol;\n    int amount;\n    bool isCall;\n    bool seenInFilter;\n  }\n\n  struct PortfolioExpiryData {\n    uint64 expiry;\n    uint optionCount;\n  }\n\n  struct Scenario {\n    uint spotShock; // i.e. 1.2e18 = 20% spot shock up\n    VolShockDirection volShock; // i.e. [Up, Down, None]\n  }\n\n  ////////////////\n  //   Events   //\n  ////////////////\n  event MaxExpiriesUpdated(uint maxExpiries);\n  event InterestRateFeedUpdated(IInterestRateFeed interestRateFeed);\n  event VolFeedUpdated(IVolFeed volFeed);\n  event SpotFeedUpdated(ISpotFeed spotFeed);\n  event StableFeedUpdated(ISpotFeed stableFeed);\n  event ForwardFeedUpdated(IForwardFeed forwardFeed);\n  event ScenariosUpdated(IPMRM.Scenario[] scenarios);\n\n  ////////////\n  // Errors //\n  ////////////\n  error PMRM_InvalidSpotShock();\n  error PMRM_UnsupportedAsset();\n  error PMRM_InsufficientMargin();\n  error PMRM_InvalidScenarios();\n  error PMRM_InvalidMaxExpiries();\n  error PMRM_FindInArrayError();\n  error PMRM_OptionExpired();\n  error PMRM_TooManyExpiries();\n  error PMRM_TooManyAssets();\n}\n"
    },
    {
      "fileName": "src/interfaces/IGlobalSubIdOITracking.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IGlobalSubIdOITracking {\n  struct SubIdOISnapshot {\n    bool initialized;\n    uint240 oi;\n  }\n\n  function openInterestBeforeTrade(uint subId, uint tradeId) external view returns (bool, uint240);\n\n  function openInterest(uint subId) external view returns (uint);\n\n  /// @dev Emitted when oi is snapshot for given subId\n  event SubIdSnapshotTaken(uint subId, uint tradeId, uint oi);\n}\n"
    },
    {
      "fileName": "src/interfaces/ISubAccounts.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IERC721} from \"openzeppelin/token/ERC721/IERC721.sol\";\nimport {IAsset} from \"./IAsset.sol\";\nimport {IManager} from \"./IManager.sol\";\n\nimport {IAllowances} from \"./IAllowances.sol\";\n\n// For full documentation refer to src/SubAccounts.sol\";\ninterface ISubAccounts is IERC721 {\n  struct BalanceAndOrder {\n    // balance of (asset, subId)\n    int240 balance;\n    // index in heldAssets() or getAccountBalances()\n    uint16 order;\n  }\n\n  struct HeldAsset {\n    IAsset asset;\n    uint96 subId;\n  }\n\n  struct AssetDelta {\n    IAsset asset;\n    uint96 subId;\n    int delta;\n  }\n\n  // the struct is used to easily manage 2 dimensional array\n  struct AssetDeltaArrayCache {\n    uint used;\n    AssetDelta[100] deltas;\n  }\n\n  /////////////////////////\n  // Memory-only Structs //\n  /////////////////////////\n\n  struct AssetBalance {\n    IAsset asset;\n    // adjustments will revert if > uint96\n    uint subId;\n    // base layer only stores up to int240\n    int balance;\n  }\n\n  struct AssetTransfer {\n    // debited by amount\n    uint fromAcc;\n    // credited by amount\n    uint toAcc;\n    // asset contract address\n    IAsset asset;\n    // adjustments will revert if >uint96\n    uint subId;\n    // reverts if transfer amount > uint240\n    int amount;\n    // data passed into asset.handleAdjustment()\n    bytes32 assetData;\n  }\n\n  struct AssetAdjustment {\n    uint acc;\n    IAsset asset;\n    // reverts for subIds > uint96\n    uint subId;\n    // reverts if transfer amount > uint240\n    int amount;\n    // data passed into asset.handleAdjustment()\n    bytes32 assetData;\n  }\n\n  ///////////////////\n  // Account Admin //\n  ///////////////////\n\n  /**\n   * @notice Creates account with new accountId\n   * @param owner new account owner\n   * @param _manager IManager of new account\n   * @return newId ID of new account\n   */\n  function createAccount(address owner, IManager _manager) external returns (uint newId);\n\n  /**\n   * @notice Creates account and gives spender full allowance\n   * @dev   @note: can be used to create and account for another user and simultaneously give allowance to oneself\n   * @param owner new account owner\n   * @param spender give address ERC721 approval\n   * @param _manager IManager of new account\n   * @return newId ID of new account\n   */\n  function createAccountWithApproval(address owner, address spender, IManager _manager) external returns (uint newId);\n\n  ///////////////\n  // Approvals //\n  ///////////////\n\n  /**\n   * @notice Sets bidirectional allowances for all subIds of an asset.\n   *         During a balance adjustment, if msg.sender not ERC721 approved or owner,\n   *         asset allowance + subId allowance must be >= amount\n   * @param accountId ID of account\n   * @param delegate address to assign allowance to\n   * @param allowances positive and negative amounts for each asset\n   */\n  function setAssetAllowances(uint accountId, address delegate, IAllowances.AssetAllowance[] memory allowances)\n    external;\n\n  /**\n   * @notice Sets bidirectional allowances for a specific subId.\n   *         During a balance adjustment, the subId allowance is decremented first\n   * @param accountId ID of account\n   * @param delegate address to assign allowance to\n   * @param allowances positive and negative amounts for each (asset, subId)\n   */\n  function setSubIdAllowances(uint accountId, address delegate, IAllowances.SubIdAllowance[] memory allowances)\n    external;\n\n  /////////////////////////\n  // Balance Adjustments //\n  /////////////////////////\n\n  /**\n   * @notice Transfer an amount from one account to another for a specific (asset, subId)\n   * @param assetTransfer (fromAcc, toAcc, asset, subId, amount)\n   * @param managerData data passed to managers of both accounts\n   */\n  function submitTransfer(AssetTransfer memory assetTransfer, bytes memory managerData) external returns (uint tradeId);\n\n  /**\n   * @notice Batch several transfers\n   *         Gas efficient when modifying the same account several times,\n   *         as _managerHook() is only performed once per account\n   * @param assetTransfers array of (fromAcc, toAcc, asset, subId, amount)\n   * @param managerData data passed to every manager involved in trade\n   */\n  function submitTransfers(AssetTransfer[] memory assetTransfers, bytes memory managerData)\n    external\n    returns (uint tradeId);\n\n  /**\n   * @notice Asymmetric balance adjustment reserved for assets\n   *         Must still pass both _managerHook()\n   * @param adjustment asymmetric adjustment of amount for (asset, subId)\n   * @param triggerAssetHook true if the adjustment need to be routed to Asset's custom hook\n   * @param managerData data passed to manager of account\n   */\n  function assetAdjustment(AssetAdjustment memory adjustment, bool triggerAssetHook, bytes memory managerData)\n    external\n    returns (int postBalance);\n\n  /**\n   * @notice Assymetric balance adjustment reserved for managers\n   *         Must still pass both _assetHook()\n   * @param adjustment assymetric adjustment of amount for (asset, subId)\n   */\n  function managerAdjustment(AssetAdjustment memory adjustment) external returns (int postBalance);\n\n  //////////\n  // View //\n  //////////\n\n  /**\n   * @dev return the manager address of the account\n   * @param accountId ID of account\n   */\n  function manager(uint accountId) external view returns (IManager);\n\n  /**\n   * @dev return the tradeId for when the account was last interacted with\n   * @param accountId ID of account\n   */\n  function lastAccountTradeId(uint accountId) external view returns (uint lastTradeId);\n\n  /**\n   * @dev return amount of asset in the account, and the order (index) of the asset in the asset array\n   * @param accountId ID of account\n   * @param asset IAsset of balance\n   * @param subId subId of balance\n   */\n  function balanceAndOrder(uint accountId, IAsset asset, uint subId)\n    external\n    view\n    returns (int240 balance, uint16 order);\n\n  /**\n   * @notice Gets an account's balance for an (asset, subId)\n   * @param accountId ID of account\n   * @param asset IAsset of balance\n   * @param subId subId of balance\n   */\n  function getBalance(uint accountId, IAsset asset, uint subId) external view returns (int balance);\n\n  /**\n   * @notice Gets a list of all asset balances of an account\n   * @dev can use balanceAndOrder() to get the index of a specific balance\n   * @param accountId ID of account\n   */\n  function getAccountBalances(uint accountId) external view returns (AssetBalance[] memory assetBalances);\n\n  /**\n   * @dev get unique assets from heldAssets.\n   *      heldAssets can hold multiple entries with same asset but different subId\n   * @param accountId ID of account\n   * @return uniqueAssets list of address\n   */\n  function getUniqueAssets(uint accountId) external view returns (address[] memory uniqueAssets);\n\n  ////////////\n  // Events //\n  ////////////\n\n  /**\n   * @dev Emitted account created or split\n   */\n  event AccountCreated(address indexed owner, uint indexed accountId, address indexed manager);\n\n  /**\n   * @dev Emitted account burned\n   */\n  event AccountBurned(address indexed owner, uint indexed accountId, address indexed manager);\n\n  /**\n   * @dev Emitted when account manager changed\n   */\n  event AccountManagerChanged(uint indexed accountId, address indexed oldManager, address indexed newManager);\n\n  /**\n   * @dev Emitted when user invalidate set of nonces\n   */\n  event UnorderedNonceInvalidated(address owner, uint wordPos, uint mask);\n\n  event AssetTransferred(\n    uint indexed fromAcc, uint indexed toAcc, IAsset asset, uint subId, int amount, bytes32 assetData, uint tradeId\n  );\n\n  /**\n   * @dev Emitted during any balance change event. This includes:\n   *      1. single transfer\n   *      2. batch transfer\n   *      3. transferAll / merge / split\n   *      4. manager or asset initiated adjustments\n   *      PreBalance + amount not necessarily = postBalance\n   */\n  event BalanceAdjusted(\n    uint indexed accountId,\n    address indexed manager,\n    bytes32 indexed assetAndSubId,\n    int amount,\n    int preBalance,\n    int postBalance,\n    uint tradeId\n  );\n\n  ////////////\n  // Errors //\n  ////////////\n\n  error AC_OnlyManager();\n\n  error AC_OnlyAsset();\n\n  error AC_TooManyTransfers();\n\n  error AC_NotOwnerOrERC721Approved(address spender, uint accountId, address owner, IManager manager, address approved);\n\n  error AC_CannotTransferAssetToOneself(address caller, uint accountId);\n\n  error AC_CannotChangeToSameManager(address caller, uint accountId);\n\n  error AC_InvalidPermitSignature();\n\n  error AC_SignatureExpired();\n\n  /// @dev nonce already used.\n  error AC_InvalidNonce();\n}\n"
    },
    {
      "fileName": "src/interfaces/IAllowances.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IAsset} from \"./IAsset.sol\";\n\n// For full documentation refer to src/Allowances.sol\";\ninterface IAllowances {\n  ////////////////\n  // Allowances //\n  ////////////////\n\n  struct AssetAllowance {\n    IAsset asset;\n    uint positive;\n    uint negative;\n  }\n\n  struct SubIdAllowance {\n    IAsset asset;\n    uint subId;\n    uint positive;\n    uint negative;\n  }\n\n  struct PermitAllowance {\n    // who to approve\n    address delegate;\n    // nonce for each signer\n    uint nonce;\n    // access are granted on account bases. A signer can have multiple accounts and the signature cannot be\n    // applied to permit another account\n    uint accountId;\n    // deadline on the permit signature\n    uint deadline;\n    // array of \"asset allowance\" to set\n    IAllowances.AssetAllowance[] assetAllowances;\n    // array of \"subid allowance\" to set\n    SubIdAllowance[] subIdAllowances;\n  }\n\n  ///////////\n  // Views //\n  ///////////\n\n  function positiveSubIdAllowance(uint accountId, address owner, IAsset asset, uint subId, address spender)\n    external\n    view\n    returns (uint);\n\n  function negativeSubIdAllowance(uint accountId, address owner, IAsset asset, uint subId, address spender)\n    external\n    view\n    returns (uint);\n\n  function positiveAssetAllowance(uint accountId, address owner, IAsset asset, address spender)\n    external\n    view\n    returns (uint);\n\n  function negativeAssetAllowance(uint accountId, address owner, IAsset asset, address spender)\n    external\n    view\n    returns (uint);\n\n  ////////////\n  // Errors //\n  ////////////\n\n  error NotEnoughSubIdOrAssetAllowances(\n    address caller, uint accountId, int amount, uint subIdAllowance, uint assetAllowance\n  );\n}\n"
    },
    {
      "fileName": "src/interfaces/ILiquidatableManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IBaseManager} from \"./IBaseManager.sol\";\nimport {IPerpAsset} from \"./IPerpAsset.sol\";\nimport {IOptionAsset} from \"./IOptionAsset.sol\";\n\ninterface ILiquidatableManager is IBaseManager {\n  /**\n   * @notice can be called by anyone to settle all perp asset in an account\n   */\n  function settlePerpsWithIndex(uint accountId) external;\n\n  /**\n   * @notice can be called by anyone to settle option assets in an account\n   */\n  function settleOptions(IOptionAsset _option, uint accountId) external;\n\n  /**\n   * @dev get initial margin or maintenance margin\n   */\n  function getMargin(uint accountId, bool isInitial) external view returns (int);\n\n  function getMarginAndMarkToMarket(uint accountId, bool isInitial, uint scenarioId) external view returns (int, int);\n}\n"
    },
    {
      "fileName": "src/interfaces/IPerpAsset.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IAsset} from \"./IAsset.sol\";\nimport {IPositionTracking} from \"./IPositionTracking.sol\";\nimport {IGlobalSubIdOITracking} from \"./IGlobalSubIdOITracking.sol\";\n\n/**\n * @title IPerpAsset\n * @notice Interface for a perpetual asset contract that extends the IAsset interface.\n */\ninterface IPerpAsset is IAsset, IPositionTracking, IGlobalSubIdOITracking {\n  struct PositionDetail {\n    // Spot price the last time user interact with perp contract\n    uint lastMarkPrice;\n    // All funding, not yet settled as cash in Accounts\n    int funding;\n    // Realized pnl, not yet settled as cash in Accounts\n    int pnl;\n    // Last aggregated funding applied to this position.\n    int lastAggregatedFunding;\n    // Timestamp of the last time funding was applied\n    uint lastFundingPaid;\n  }\n\n  /**\n   * @notice Manager-only function to clear pnl and funding during settlement\n   * @dev The manager should then update the cash balance of an account base on the returned netCash variable\n   */\n  function settleRealizedPNLAndFunding(uint accountId) external returns (int pnl, int funding);\n\n  function getUnsettledAndUnrealizedCash(uint accountId) external view returns (int totalCash);\n\n  function realizeAccountPNL(uint account) external;\n\n  function getIndexPrice() external view returns (uint, uint);\n\n  function getPerpPrice() external view returns (uint, uint);\n\n  function getImpactPrices() external view returns (uint bid, uint ask);\n\n  //////////////////\n  //   Events     //\n  //////////////////\n\n  event StaticUnderlyingInterestRateUpdated(int premium);\n\n  event SpotFeedUpdated(address spotFeed);\n\n  event PerpFeedUpdated(address perpFeed);\n\n  event ImpactFeedsUpdated(address askImpactFeed, address bidImpactFeed);\n\n  event RateBoundsUpdated(int maxAbsRatePerHour);\n\n  event ConvergencePeriodUpdated(int fundingConvergencePeriod);\n\n  event Disabled(int indexPrice, int aggregatedFunding);\n\n  event AggregatedFundingUpdated(int aggregatedFundingRate, int fundingRate, uint lastFundingPaidAt);\n\n  event FundingAppliedOnAccount(uint accountId, int funding, int aggregatedFundingRate);\n\n  event PositionSettled(uint indexed account, int pnlChange, int totalPnl, uint perpPrice);\n\n  event PositionCleared(uint indexed account);\n\n  ////////////////\n  //   Errors   //\n  ////////////////\n\n  /// @dev SubId is not 0\n  error PA_InvalidSubId();\n\n  /// @dev Settlement can only be initiated by the manager of the account\n  error PA_WrongManager();\n\n  /// @dev Impact prices are invalid: bids higher than ask or negative\n  error PA_InvalidImpactPrices();\n\n  error PA_InvalidRateBounds();\n\n  error PA_InvalidConvergencePeriod();\n\n  error PA_InvalidStaticInterestRate();\n}\n"
    },
    {
      "fileName": "src/interfaces/IForwardFeed.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\n/**\n * @title IForwardFeed\n * @author Lyra\n * @notice return forward feed for 1 asset\n */\n\ninterface IForwardFeed {\n  /**\n   * @notice Gets forward price for a particular asset\n   * @param expiry Forward expiry to query\n   */\n  function getForwardPrice(uint64 expiry) external view returns (uint forwardPrice, uint confidence);\n  function getForwardPricePortions(uint64 expiry)\n    external\n    view\n    returns (uint forwardFixedPortion, uint forwardVariablePortion, uint confidence);\n}\n"
    },
    {
      "fileName": "src/interfaces/IVolFeed.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IVolFeed {\n  function getVol(uint128 strike, uint64 expiry) external view returns (uint vol, uint confidence);\n\n  function getExpiryMinConfidence(uint64 expiry) external view returns (uint confidence);\n\n  ////////////\n  // Events //\n  ////////////\n\n  /// @dev Emitted when spot price for option settlement determined\n  event VolSet(uint128 strike, uint128 expiry, uint128 vol, uint64 confidence);\n}\n"
    },
    {
      "fileName": "src/interfaces/IBaseManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IManager} from \"./IManager.sol\";\n\ninterface IBaseManager is IManager {\n  /////////////\n  // Structs //\n  /////////////\n\n  struct ManagerData {\n    address receiver;\n    bytes data;\n  }\n\n  struct SettleUnrealizedPNLData {\n    uint accountId;\n    address perp; // this needs to be verified\n  }\n\n  /**\n   * @notice settle interest for an account\n   */\n  function settleInterest(uint accountId) external;\n\n  function feeCharged(uint tradeId, uint account) external view returns (uint);\n\n  function executeBid(uint accountId, uint liquidatorId, uint portion, uint cashAmount, uint reservedCash) external;\n\n  function payLiquidationFee(uint accountId, uint recipient, uint cashAmount) external;\n\n  function maxAccountSize() external view returns (uint);\n\n  ////////////////\n  //   Events   //\n  ////////////////\n\n  event LiquidationSet(address liquidation);\n\n  event MinOIFeeSet(uint minOIFee);\n\n  event GuardianSet(address guardian);\n\n  event AdjustmentsPausedSet(bool paused);\n\n  event CalleeWhitelisted(address callee);\n\n  event PerpSettled(uint indexed accountId, address perp, int pnl, int funding);\n\n  event OptionSettled(uint indexed accountId, address option, uint subId, int amount, int value);\n\n  event FeeBypassedCallerSet(address caller, bool bypassed);\n\n  event FeeRecipientSet(uint _newAcc);\n\n  event MaxAccountSizeUpdated(uint maxAccountSize);\n\n  event TrustedRiskAssessorUpdated(address riskAssessor, bool trusted);\n\n  ////////////\n  // Errors //\n  ////////////\n\n  error BM_InvalidLiquidation();\n\n  error BM_MinOIFeeTooHigh();\n\n  error BM_GuardianOnly();\n\n  error BM_AdjustmentsPaused();\n\n  error BM_InvalidBidPortion();\n\n  error BM_AccountUnderLiquidation();\n\n  error BM_OnlyLiquidationModule();\n\n  error BM_OnlyAccounts();\n\n  error BM_AssetCapExceeded();\n\n  error BM_UnauthorizedCall();\n\n  error BM_InvalidMaxAccountSize();\n\n  error BM_NotImplemented();\n}\n"
    },
    {
      "fileName": "src/interfaces/IDutchAuction.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {ICashAsset} from \"./ICashAsset.sol\";\n\ninterface IDutchAuction {\n  struct Auction {\n    /// the accountId that is being liquidated\n    uint accountId;\n    /// scenario ID used to calculate IM or MtM. Ignored for Basic Manager\n    uint scenarioId;\n    /// Boolean that will be switched when the auction price passes through 0\n    bool insolvent;\n    /// If an auction is active\n    bool ongoing;\n    /// For insolvent auctions, snapshot MM at the time the auction starts\n    uint cachedMM;\n    /// The startTime of the auction\n    uint startTime;\n    /// The total amount of cash paid into the account during the auction\n    uint reservedCash;\n  }\n\n  struct AuctionParams {\n    /// Starting percentage of MtM. 1e18 is 100%\n    uint startingMtMPercentage;\n    /// Percentage that starts the slow auction\n    uint fastAuctionCutoffPercentage;\n    /// Fast auction length in seconds\n    uint fastAuctionLength;\n    /// Slow auction length in seconds\n    uint slowAuctionLength;\n    /// Insolvent auction length in seconds\n    uint insolventAuctionLength;\n    // Liquidator fee rate in percentage, 1e18 = 100%\n    uint liquidatorFeeRate;\n    // Buffer margin percentage, 1.2e18 = 120%\n    uint bufferMarginPercentage;\n  }\n\n  function cash() external view returns (ICashAsset);\n\n  function startAuction(uint accountId, uint scenarioId) external;\n\n  function getIsWithdrawBlocked() external view returns (bool);\n\n  function isAuctionLive(uint accountId) external view returns (bool);\n\n  ////////////\n  // EVENTS //\n  ////////////\n\n  // emitted when a solvent auction starts\n  event SolventAuctionStarted(uint accountId, uint scenarioId, int markToMarket, uint fee);\n\n  // emitted when an insolvent auction starts\n  event InsolventAuctionStarted(uint accountId, uint scenarioId, int maintenanceMargin);\n\n  // emitted when a bid is placed\n  event Bid(uint accountId, uint bidderId, uint finalPercentage, uint cashFromBidder, uint cashToBidder);\n\n  // emitted when an auction ends, either by insolvency or by the assets of an account being purchased.\n  event AuctionEnded(uint accountId, uint endTime);\n\n  event InsolventAuctionStepIncremented(uint accountId, uint newStep);\n\n  event ScenarioIdUpdated(uint accountId, uint newScenarioId);\n\n  event AuctionParamsSet(AuctionParams params);\n\n  event SMAccountSet(uint smAccount);\n\n  ////////////\n  // ERRORS //\n  ////////////\n\n  /// @dev emitted owner is trying to set a bad parameter for auction\n  error DA_InvalidParameter();\n\n  /// @dev emitted owner is trying to set bad threshold that could block cash withdraw\n  error DA_InvalidWithdrawBlockThreshold();\n\n  /// @dev Cannot stop an ongoing auction\n  error DA_NotOngoingAuction();\n\n  /// @dev emitted when someone tries to start an insolvent auction when bidding\n  /// has not concluded.\n  error DA_OngoingSolventAuction();\n\n  /// @dev revert if trying to start an auction when it's above maintenance margin (well collateralized)\n  error DA_AccountIsAboveMaintenanceMargin();\n\n  /// @dev revert if trying to end an auction when it's below maintenance margin\n  error DA_AccountIsBelowMaintenanceMargin();\n\n  /// @dev emitted when someone tries mark an insolvent auction again\n  error DA_AuctionAlreadyInInsolvencyMode();\n\n  /// @dev emitted when someone tries to bid on auction that has not started\n  error DA_AuctionNotStarted();\n\n  /// @dev emitted when a risk manager tries to start an auction that has already been started\n  error DA_AuctionAlreadyStarted();\n\n  /// @dev emitted when a bid is submitted on a solvent auction that has passed the auction time\n  ///      at this point, it can be converted into insolvent auction and keep going.\n  error DA_SolventAuctionEnded();\n\n  /// @dev emitted when a bid is submitted where percentage > 100% of portfolio\n  error DA_InvalidPercentage();\n\n  /// @dev emitted when a bid is submitted and the lastTradeId of the account mismatches the expected value\n  error DA_InvalidLastTradeId();\n\n  /// @dev emitted when a bid is submitted for 0% of the portfolio\n  error DA_AmountIsZero();\n\n  /// @dev emitted when a bidder doesn't have only cash in their portfolio\n  error DA_InvalidBidderPortfolio();\n\n  /// @dev emitted when bidder doesn't have enough cash for bidding\n  error DA_InsufficientCash();\n\n  /// @dev emitted when an bidder bid on an insolvent auction, but the bidder is insolvent\n  error DA_BidderInsolvent();\n\n  /// @dev emitted when bidder specified max cash is exceeded by the bid\n  error DA_PriceLimitExceeded();\n\n  /// @dev emitted when owner trying to set a invalid buffer margin param\n  error DA_InvalidBufferMarginParameter();\n\n  /// @dev emitted when a user doesn't own the account that they are trying to bid from\n  error DA_SenderNotOwner();\n\n  /// @dev emitted when a user tries to terminate an auction but the account is still underwater\n  error DA_AuctionCannotTerminate();\n\n  /// @dev can only specify an id that make the IM worse\n  error DA_ScenarioIdNotWorse();\n\n  /// @dev emitted when a user tries to bid on an auction, but it should be terminated\n  error DA_AuctionShouldBeTerminated();\n\n  /// @dev emitted when reserved cash exceeds MTM. Auction should be terminated and restarted.\n  error DA_ReservedCashGreaterThanMtM();\n\n  /// @dev emitted when calling force liquidate not from the account's manager.\n  error DA_OnlyManager();\n}\n"
    },
    {
      "fileName": "src/interfaces/IPositionTracking.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IManager} from \"./IManager.sol\";\n\ninterface IPositionTracking {\n  /////////////////\n  //   Structs   //\n  /////////////////\n\n  struct OISnapshot {\n    bool initialized;\n    uint240 oi;\n  }\n\n  function setTotalPositionCap(IManager manager, uint oiCap) external;\n\n  function totalPositionCap(IManager manager) external view returns (uint);\n\n  function totalPositionBeforeTrade(IManager manager, uint tradeId) external view returns (bool, uint240);\n\n  function totalPosition(IManager manager) external view returns (uint);\n\n  /// @dev Emitted when snapshot is taken for totalOi\n  event SnapshotTaken(address manager, uint tradeId, uint oi);\n\n  /// @dev Emitted when OI cap is set\n  event TotalPositionCapSet(address manager, uint oiCap);\n\n  /// @dev Reverts if total position exceeds cap\n  error PT_CapExceeded();\n}\n"
    },
    {
      "fileName": "src/interfaces/IERC20BasedAsset.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport \"openzeppelin/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IAsset} from \"./IAsset.sol\";\n\ninterface IERC20BasedAsset is IAsset {\n  function wrappedAsset() external view returns (IERC20Metadata);\n  function deposit(uint recipientAccount, uint assetAmount) external;\n  function withdraw(uint accountId, uint assetAmount, address recipient) external;\n\n  /// @dev emitted when a user deposits to an account\n  event Deposit(uint indexed accountId, address indexed depositor, uint amountAssetMinted, uint wrappedAssetDeposited);\n\n  /// @dev emitted when a user withdraws from an account\n  event Withdraw(uint indexed accountId, address indexed recipient, uint amountAssetBurn, uint wrappedAssetWithdrawn);\n}\n"
    },
    {
      "fileName": "src/interfaces/IManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {ISubAccounts} from \"./ISubAccounts.sol\";\n\ninterface IManager {\n  /**\n   * @notice triggered at the end of a tx when any balance of the account is updated\n   * @dev a manager should properly check the final stateo of an account\n   * @param tradeId unique number attached to a batched transfers.\n   *                It is possible that this hook will receive multiple calls with different tradeIds within 1 transaction if there were\n   *                recursive calls to Account.submitTransfer (call submitTrnasfer again in this hook).\n   */\n  function handleAdjustment(\n    uint accountId,\n    uint tradeId,\n    address caller,\n    ISubAccounts.AssetDelta[] memory deltas,\n    bytes memory data\n  ) external;\n}\n"
    },
    {
      "fileName": "src/interfaces/IPMRMLib.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IPMRM} from \"./IPMRM.sol\";\n\ninterface IPMRMLib {\n  struct VolShockParameters {\n    /// @dev The max vol shock, that can be scaled down\n    uint volRangeUp;\n    /// @dev The max\n    uint volRangeDown;\n    int shortTermPower;\n    int longTermPower;\n    uint dteFloor;\n  }\n\n  struct MarginParameters {\n    uint imFactor;\n    uint rateMultScale;\n    uint rateAddScale;\n    uint baseStaticDiscount;\n  }\n\n  struct BasisContingencyParameters {\n    uint scenarioSpotUp;\n    uint scenarioSpotDown;\n    uint basisContAddFactor;\n    uint basisContMultFactor;\n  }\n\n  struct OtherContingencyParameters {\n    /// @dev Below this threshold, we consider the stable asset de-pegged, so we add additional contingency\n    uint pegLossThreshold;\n    /// @dev If below the peg loss threshold, we add this contingency\n    uint pegLossFactor;\n    /// @dev Below this threshold, IM is affected by confidence contingency\n    uint confThreshold;\n    /// @dev Percentage of spot used for confidence contingency, scales with the minimum contingency seen.\n    uint confMargin;\n    /// @dev Contingency applied to base held in the portfolio, multiplied by spot.\n    uint basePercent;\n    /// @dev Contingency applied to perps held in the portfolio, multiplied by spot.\n    uint perpPercent;\n    /// @dev Factor for multiplying number of naked shorts (per strike) in the portfolio, multipled by spot.\n    uint optionPercent;\n  }\n\n  function getMarginAndMarkToMarket(IPMRM.Portfolio memory portfolio, bool isInitial, IPMRM.Scenario[] memory scenarios)\n    external\n    view\n    returns (int margin, int markToMarket, uint worstScenario);\n\n  function getScenarioMtM(IPMRM.Portfolio memory portfolio, IPMRM.Scenario memory scenario)\n    external\n    view\n    returns (int scenarioMtM);\n\n  function addPrecomputes(IPMRM.Portfolio memory portfolio) external view returns (IPMRM.Portfolio memory);\n\n  function getBasisContingencyScenarios() external view returns (IPMRM.Scenario[] memory);\n\n  ////////////\n  // Errors //\n  ////////////\n\n  /// @dev emitted when provided forward contingency parameters are invalid\n  error PMRML_InvalidBasisContingencyParameters();\n  /// @dev emitted when provided other contingency parameters are invalid\n  error PMRML_InvalidOtherContingencyParameters();\n  /// @dev emitted when provided static discount parameters are invalid\n  error PMRML_InvalidMarginParameters();\n  /// @dev emitted when provided vol shock parameters are invalid\n  error PMRML_InvalidVolShockParameters();\n  /// @dev emitted when invalid parameters passed into _getMarginAndMarkToMarket\n  error PMRML_InvalidGetMarginState();\n}\n"
    },
    {
      "fileName": "src/interfaces/ICashAsset.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IAsset} from \"./IAsset.sol\";\nimport {IInterestRateModel} from \"./IInterestRateModel.sol\";\nimport {IManager} from \"./IManager.sol\";\nimport {IERC20Metadata} from \"openzeppelin/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IERC20BasedAsset} from \"./IERC20BasedAsset.sol\";\n\ninterface ICashAsset is IERC20BasedAsset {\n  /**\n   * @dev Deposit and create a new account\n   * @param recipient user for who the new account is created\n   * @param stableAmount amount of stable coins to deposit\n   * @param manager manager of the new account\n   */\n  function depositToNewAccount(address recipient, uint stableAmount, IManager manager)\n    external\n    returns (uint newAccountId);\n\n  /**\n   * @notice Liquidation module can report loss when there is insolvency.\n   *         This function will \"print\" the amount of cash to the target account\n   *         and socialize the loss to everyone in the system\n   *         this will result in turning on withdraw fee if the contract is indeed insolvent\n   * @param lossAmountInCash Total amount of cash loss\n   * @param accountToReceive Account to receive the new printed amount\n   */\n  function socializeLoss(uint lossAmountInCash, uint accountToReceive) external;\n\n  /**\n   * @notice Returns latest balance without updating accounts but will update indexes\n   * @param accountId The accountId to check\n   */\n  function calculateBalanceWithInterest(uint accountId) external returns (int balance);\n\n  /**\n   * @dev Returns the exchange rate from cash asset to stable asset\n   *      this should always be equal to 1, unless we have an insolvency\n   */\n  function getCashToStableExchangeRate() external view returns (uint);\n\n  /**\n   * @notice Allows whitelisted manager to adjust netSettledCash\n   * @dev Required to track printed cash for asymmetric settlements\n   * @param amountCash Amount of cash printed or burned\n   */\n  function updateSettledCash(int amountCash) external;\n\n  /**\n   * @notice Allows the account's risk manager to forcefully send all cash to the account owner\n   */\n  function forceWithdraw(uint accountId) external;\n\n  function donateBalance(uint accountId, uint amount) external returns (uint burntAmount);\n\n  ////////////////\n  //   Events   //\n  ////////////////\n\n  /// @dev Emitted when interest related state variables are updated\n  event InterestAccrued(uint interestAccrued, uint borrowIndex, uint supplyIndex, uint totalSupply, uint totalBorrow);\n\n  /// @dev Emitted when the security module fee is set\n  event SmFeeSet(uint fee);\n\n  /// @dev Emitted when the recipient is set\n  event SmFeeRecipientSet(uint recipientAcc);\n\n  /// @dev Emitted when a new liquidation module is set\n  event LiquidationModuleSet(address liquidationModule);\n\n  /// @dev Emitted when a new interest rate model is set\n  event InterestRateModelSet(IInterestRateModel rateModel);\n\n  /// @dev Emitted when asymmetric print/burn occurs for settlement\n  event SettledCashUpdated(int amountChanged, int currentSettledCash);\n\n  /// @dev emitted when withdraw fee is enabled\n  ///      this would imply there is an insolvency and loss is applied to all cash holders\n  event WithdrawFeeEnabled(uint exchangeRate);\n\n  /// @dev emitted when withdraw fee is disabled\n  ///      this can only occur if the cash asset is solvent again\n  event WithdrawFeeDisabled(uint exchangeRate);\n\n  /// @dev emitted when an interest accrued on an existing account's pre balance\n  event InterestAccruedOnAccount(uint indexed accountId, int preBalance, int interestAccrued, uint accountIndex);\n\n  ////////////////\n  //   Errors   //\n  ////////////////\n\n  /// @dev caller is not account\n  error CA_NotAccount();\n\n  /// @dev SubId passed into adjustment is not 0\n  error CA_InvalidSubId();\n\n  /// @dev caller is not the liquidation module\n  error CA_NotLiquidationModule();\n\n  /// @dev revert when user trying to upgrade to a unknown manager\n  error CA_UnknownManager();\n\n  /// @dev caller is not owner of the account\n  error CA_OnlyAccountOwner();\n\n  /// @dev withdraw is temporarily block due to on-going insolvent auction\n  error CA_WithdrawBlockedByOngoingAuction();\n\n  /// @dev accrued interest is stale\n  error CA_InterestAccrualStale(uint lastUpdatedAt, uint currentTimestamp);\n\n  /// @dev Security module fee cut greater than 100%\n  error CA_SmFeeInvalid(uint fee);\n\n  /// @dev The caller of force withdraw was not the account's risk manager\n  error CA_ForceWithdrawNotAuthorized();\n\n  /// @dev Calling force withdraw when user has a negative balance\n  error CA_ForceWithdrawNegativeBalance();\n\n  /// @dev Only the owner of the account can call the donate function\n  error CA_DonateBalanceNotAuthorized();\n}\n"
    },
    {
      "fileName": "src/interfaces/IDataReceiver.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\n/**\n * @title IDataReceiver\n * @author Lyra\n * @notice Interface for oracles that takes data off-chain with signer data\n */\ninterface IDataReceiver {\n  function acceptData(bytes calldata data) external;\n}\n"
    },
    {
      "fileName": "src/interfaces/IInterestRateFeed.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IInterestRateFeed {\n  function getInterestRate(uint64 expiry) external view returns (int interestRate, uint confidence);\n}\n"
    },
    {
      "fileName": "src/interfaces/ISpotFeed.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\n/**\n * @title ISpotFeed\n * @author Lyra\n * @notice Spot feed adapter\n * @dev `spotPrice` always assumed to return 18 decimal place uint\n */\ninterface ISpotFeed {\n  /**\n   * @notice Gets spot price and confidence\n   * @return spotPrice 18 decimal price of trading pair.\n   */\n  function getSpot() external view returns (uint spotPrice, uint confidence);\n}\n"
    },
    {
      "fileName": "src/interfaces/IBasePortfolioViewer.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {ISubAccounts} from \"../interfaces/ISubAccounts.sol\";\n\nimport {IGlobalSubIdOITracking} from \"../interfaces/IGlobalSubIdOITracking.sol\";\nimport {IManager} from \"../interfaces/IManager.sol\";\n\n/**\n * @title IBasePortfolioViewer\n * @author Lyra\n */\ninterface IBasePortfolioViewer {\n  error BM_AssetCapExceeded();\n\n  error BM_OIFeeRateTooHigh();\n\n  function getAssetOIFee(IGlobalSubIdOITracking asset, uint subId, int delta, uint tradeId, uint price)\n    external\n    view\n    returns (uint fee);\n\n  function checkAllAssetCaps(IManager manager, uint accountId, uint tradeId) external view;\n\n  function getPreviousAssetsLength(\n    ISubAccounts.AssetBalance[] memory assetBalances,\n    ISubAccounts.AssetDelta[] memory assetDeltas\n  ) external view returns (uint);\n\n  /// @dev Emitted when OI fee rate is set\n  event OIFeeRateSet(address asset, uint oiFeeRate);\n}\n"
    },
    {
      "fileName": "src/interfaces/IAsset.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IManager} from \"./IManager.sol\";\nimport {ISubAccounts} from \"./ISubAccounts.sol\";\n\ninterface IAsset {\n  /**\n   * @notice triggered when an adjustment is triggered on the asset balance\n   * @param adjustment details about adjustment, containing account, subId, amount\n   * @param tradeId unique number attached to a batched transfers.\n   *                It is possible that this hook will receive multiple calls with different tradeIds within 1 transaction.\n   * @param preBalance balance before adjustment\n   * @param manager the manager contract that will verify the end state. Should verify if this is a trusted manager\n   * @param caller the msg.sender that initiate the transfer. might not be the owner\n   * @return finalBalance the final balance to be recorded in the account\n   * @return needAllowance if this adjustment should require allowance from non-ERC721 approved initiator\n   */\n  function handleAdjustment(\n    ISubAccounts.AssetAdjustment memory adjustment,\n    uint tradeId,\n    int preBalance,\n    IManager manager,\n    address caller\n  ) external returns (int finalBalance, bool needAllowance);\n}\n"
    },
    {
      "fileName": "src/interfaces/IOptionAsset.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IAsset} from \"./IAsset.sol\";\nimport {IManager} from \"./IManager.sol\";\n\nimport {IPositionTracking} from \"./IPositionTracking.sol\";\nimport {IGlobalSubIdOITracking} from \"./IGlobalSubIdOITracking.sol\";\n\ninterface IOptionAsset is IAsset, IPositionTracking, IGlobalSubIdOITracking {\n  ///////////////////\n  //   Functions   //\n  ///////////////////\n\n  /**\n   * @notice Get settlement value of a specific option.\n   * @dev Will return false if option not settled yet.\n   * @param subId ID of option.\n   * @param balance Amount of option held.\n   * @return payout Amount the holder will receive or pay when position is settled\n   * @return priceSettled Whether the settlement price of the option has been set.\n   */\n  function calcSettlementValue(uint subId, int balance) external view returns (int payout, bool priceSettled);\n\n  ////////////////\n  //   Events   //\n  ////////////////\n  event SettlementFeedSet(address settlementFeed);\n\n  ////////////////\n  //   Errors   //\n  ////////////////\n\n  /// @dev revert if caller is not Accounts\n  error OA_NotAccounts();\n\n  /// @dev revert when settlement is triggered from unknown managers\n  error OA_UnknownManager();\n}\n"
    }
  ]
}