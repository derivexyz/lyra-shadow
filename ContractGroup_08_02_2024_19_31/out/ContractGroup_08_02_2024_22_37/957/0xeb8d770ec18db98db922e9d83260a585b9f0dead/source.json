{"compilerVersion":"v0.8.18+commit.87f61d96","language":"Solidity","remappings":[],"contractFiles":[{"fileName":"ActionVerifier.sol","content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.13;\n\nimport \"forge-std/console2.sol\";\n\n// Libraries\nimport \"openzeppelin/utils/cryptography/SignatureChecker.sol\";\n\n// Inherited\nimport \"openzeppelin/utils/cryptography/EIP712.sol\";\nimport {SubAccountsManager} from \"./SubAccountsManager.sol\";\nimport {IActionVerifier} from \"./interfaces/IActionVerifier.sol\";\n\n// Interfaces\nimport {IMatchingModule} from \"./interfaces/IMatchingModule.sol\";\nimport {ISubAccounts} from \"v2-core/src/interfaces/ISubAccounts.sol\";\n\n/**\n * @title ActionVerifier\n * @dev Handles signature verification and session keys for actions\n */\ncontract ActionVerifier is IActionVerifier, SubAccountsManager, EIP712 {\n  bytes32 public constant ACTION_TYPEHASH = keccak256(\n    \"Action(uint256 subaccountId,uint256 nonce,address module,bytes data,uint256 expiry,address owner,address signer)\"\n  );\n\n  uint public constant DEREGISTER_KEY_COOLDOWN = 10 minutes;\n\n  /// @notice Allows other addresses to trade on behalf of users\n  /// @dev Mapping of signer address -> owner address -> expiry\n  mapping(address signer => mapping(address owner => uint)) public sessionKeys;\n\n  constructor(ISubAccounts _accounts) SubAccountsManager(_accounts) EIP712(\"Matching\", \"1.0\") {}\n\n  /**\n   * @notice Allows owners to a register session key to authorize actions for deposited subAccounts.\n   * @dev Registered address gains owner address permission to the subAccount until expiry.\n   * @param expiry When the access to the owner address expires\n   */\n  function registerSessionKey(address sessionKey, uint expiry) external {\n    if (expiry <= sessionKeys[sessionKey][msg.sender]) revert OV_NeedDeregister();\n\n    sessionKeys[sessionKey][msg.sender] = expiry;\n\n    emit SessionKeyRegistered(msg.sender, sessionKey, expiry);\n  }\n\n  /**\n   * @notice Allows owner to deregister a session key.\n   * @dev Expires the sessionKey after the cooldown.\n   */\n  function deregisterSessionKey(address sessionKey) external {\n    // Ensure the session key has not expired\n    if (sessionKeys[sessionKey][msg.sender] < block.timestamp) revert OV_SessionKeyInvalid();\n\n    sessionKeys[sessionKey][msg.sender] = block.timestamp + DEREGISTER_KEY_COOLDOWN;\n    emit SessionKeyCooldown(msg.sender, sessionKey);\n  }\n\n  function domainSeparator() external view returns (bytes32) {\n    return _domainSeparatorV4();\n  }\n\n  function getActionHash(Action memory action) external pure returns (bytes32) {\n    return _getActionHash(action);\n  }\n\n  /////////////////////////////\n  //    Internal Functions   //\n  /////////////////////////////\n\n  /**\n   * @notice Verify that the signer is the owner or has been permitted to trade on behalf of the owner\n   * @param signer The address that signed the action\n   * @param accIdOwner the original owner of the subaccount stored by matching contract\n   * @param owner specified owner in the action\n   */\n  function _verifySignerPermission(address signer, address accIdOwner, address owner) internal view {\n    if (accIdOwner != address(0) && accIdOwner != owner) revert OV_InvalidActionOwner();\n\n    if (signer != owner && sessionKeys[signer][owner] < block.timestamp) {\n      revert OV_SignerNotOwnerOrSessionKeyExpired();\n    }\n  }\n\n  /**\n   * @notice Verify that the action is properly authorized by the original owner.\n   * @param action The action to verify.\n   * @param signature The signature signed by the owner or registered sessionKey.\n   */\n  function _verifyAction(Action memory action, bytes memory signature)\n    internal\n    view\n    returns (IMatchingModule.VerifiedAction memory)\n  {\n    // Repeated nonces are fine; their uniqueness will be handled by modules\n    if (block.timestamp > action.expiry) revert OV_ActionExpired();\n\n    _verifySignerPermission(action.signer, subAccountToOwner[action.subaccountId], action.owner);\n\n    _verifySignature(action.signer, _getActionHash(action), signature);\n\n    return IMatchingModule.VerifiedAction({\n      subaccountId: action.subaccountId,\n      owner: action.owner,\n      module: action.module,\n      data: action.data,\n      nonce: action.nonce\n    });\n  }\n\n  /**\n   * @notice Verify that the signature is valid.\n   * @dev if signer is a contract, use ERC1271 to verify the signature\n   */\n  function _verifySignature(address signer, bytes32 structuredHash, bytes memory signature) internal view {\n    if (!SignatureChecker.isValidSignatureNow(signer, _hashTypedDataV4(structuredHash), signature)) {\n      revert OV_InvalidSignature();\n    }\n  }\n\n  function _getActionHash(Action memory action) internal pure returns (bytes32) {\n    return keccak256(\n      abi.encode(\n        ACTION_TYPEHASH,\n        action.subaccountId,\n        action.nonce,\n        address(action.module),\n        keccak256(action.data),\n        action.expiry,\n        action.owner,\n        action.signer\n      )\n    );\n  }\n}\n"},{"fileName":"Matching.sol","content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.13;\n\n// Inherited\nimport {ActionVerifier} from \"./ActionVerifier.sol\";\nimport {IMatching} from \"./interfaces/IMatching.sol\";\n\n// Interfaces\nimport {ISubAccounts} from \"v2-core/src/interfaces/ISubAccounts.sol\";\nimport {IMatchingModule} from \"./interfaces/IMatchingModule.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\n\ncontract Matching is IMatching, ActionVerifier {\n  /// @dev Permissioned address to execute trades\n  mapping(address tradeExecutor => bool canExecuteTrades) public tradeExecutors;\n\n  /// @dev Permissioned modules to be invoked\n  mapping(address module => bool) public allowedModules;\n\n  constructor(ISubAccounts _accounts) ActionVerifier(_accounts) {}\n\n  ////////////////////////////\n  //       Owner-only       //\n  ////////////////////////////\n\n  /**\n   * @notice Set which address can submit trades.\n   */\n  function setTradeExecutor(address tradeExecutor, bool canExecute) external onlyOwner {\n    tradeExecutors[tradeExecutor] = canExecute;\n\n    emit TradeExecutorSet(tradeExecutor, canExecute);\n  }\n\n  /**\n   * @dev Set an action module to be allowed or disallowed\n   */\n  function setAllowedModule(address module, bool allowed) external onlyOwner {\n    allowedModules[module] = allowed;\n\n    emit ModuleAllowed(module, allowed);\n  }\n\n  /**\n   * @dev This contract should never hold any funds, but just in case, allow the owner to withdraw\n   */\n  function withdrawERC20(address token, address recipient, uint amount) external onlyOwner {\n    IERC20(token).transfer(recipient, amount);\n  }\n\n  /////////////////////////////\n  //    Guarded Functions    //\n  /////////////////////////////\n\n  function verifyAndMatch(Action[] memory actions, bytes[] memory signatures, bytes memory actionData)\n    public\n    onlyTradeExecutor\n  {\n    IMatchingModule module = actions[0].module;\n\n    if (!allowedModules[address(module)]) revert M_OnlyAllowedModule();\n    if (actions.length != signatures.length) revert M_ArrayLengthMismatch();\n\n    IMatchingModule.VerifiedAction[] memory verifiedActions = new IMatchingModule.VerifiedAction[](actions.length);\n    for (uint i = 0; i < actions.length; i++) {\n      if (actions[i].module != module) revert M_MismatchedModule();\n      verifiedActions[i] = _verifyAction(actions[i], signatures[i]);\n    }\n    _submitModuleAction(module, verifiedActions, actionData);\n  }\n\n  /////////////////////////////\n  //    Internal Functions   //\n  /////////////////////////////\n\n  /**\n   * @notice sent array of signed actions to the module contract\n   * @dev expect the module to transfer the ownership back to Matching.sol at the end\n   */\n  function _submitModuleAction(\n    IMatchingModule module,\n    IMatchingModule.VerifiedAction[] memory actions,\n    bytes memory actionData\n  ) internal {\n    // Transfer accounts to the module contract\n    for (uint i = 0; i < actions.length; ++i) {\n      // Allow signing messages with accountId == 0, where no account needs to be transferred.\n      if (actions[i].subaccountId == 0) continue;\n\n      // If the account has been previously sent (actions can share accounts), skip it.\n      if (subAccounts.ownerOf(actions[i].subaccountId) == address(module)) continue;\n\n      subAccounts.transferFrom(address(this), address(module), actions[i].subaccountId);\n    }\n\n    (uint[] memory newAccIds, address[] memory newOwners) = module.executeAction(actions, actionData);\n\n    // Ensure accounts are transferred back,\n    for (uint i = 0; i < actions.length; ++i) {\n      if (actions[i].subaccountId != 0 && subAccounts.ownerOf(actions[i].subaccountId) != address(this)) {\n        revert M_AccountNotReturned();\n      }\n    }\n\n    // Receive back a list of new subaccounts and respective owners. This allows modules to open new accounts\n    if (newAccIds.length != newOwners.length) revert M_ArrayLengthMismatch();\n    for (uint i = 0; i < newAccIds.length; ++i) {\n      if (subAccounts.ownerOf(newAccIds[i]) != address(this)) revert M_AccountNotReturned();\n      if (subAccountToOwner[newAccIds[i]] != address(0)) revert M_AccountAlreadyExists();\n\n      subAccountToOwner[newAccIds[i]] = newOwners[i];\n      emit DepositedSubAccount(newAccIds[i], newOwners[i]);\n    }\n  }\n\n  ///////////////////\n  //   Modifiers   //\n  ///////////////////\n\n  modifier onlyTradeExecutor() {\n    if (!tradeExecutors[msg.sender]) revert M_OnlyTradeExecutor();\n    _;\n  }\n}\n"},{"fileName":"SubAccountsManager.sol","content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.13;\n\n// Inherited\nimport {Ownable2Step} from \"openzeppelin/access/Ownable2Step.sol\";\nimport {ISubAccountsManager} from \"./interfaces/ISubAccountsManager.sol\";\n\n// Interfaces\nimport {ISubAccounts} from \"v2-core/src/interfaces/ISubAccounts.sol\";\nimport {IManager} from \"v2-core/src/interfaces/IManager.sol\";\n\n/**\n * @title SubAccountsManager\n * @dev Handle deposits, escape hatches for subAccounts. Users need to deposit their subAccount NFTs to use the Matching contract\n */\ncontract SubAccountsManager is ISubAccountsManager, Ownable2Step {\n  ///@dev Cooldown seconds a user must wait before withdrawing their account\n  uint public constant WITHDRAW_COOLDOWN = 30 minutes;\n\n  ///@dev Accounts contract address\n  ISubAccounts public immutable subAccounts;\n\n  ///@dev Mapping of accountId to address\n  mapping(uint => address) public subAccountToOwner;\n\n  ///@dev Mapping of account to withdraw cooldown start time\n  mapping(uint => uint) public withdrawTimestamp;\n\n  constructor(ISubAccounts _subAccounts) {\n    subAccounts = _subAccounts;\n  }\n\n  /**\n   * @notice Allows user to open an account by creating a new subAccount NFT.\n   * @param manager The address of the manager for the new subAccount\n   */\n  function createSubAccount(IManager manager) external returns (uint accountId) {\n    accountId = subAccounts.createAccount(address(this), manager);\n    subAccountToOwner[accountId] = msg.sender;\n\n    emit DepositedSubAccount(accountId, msg.sender);\n  }\n\n  /**\n   * @notice Allows user to open an account by transferring their account NFT to this contract.\n   * @dev User must approve contract first.\n   * @param accountId The users' accountId\n   */\n  function depositSubAccount(uint accountId) external {\n    subAccounts.transferFrom(msg.sender, address(this), accountId);\n    subAccountToOwner[accountId] = msg.sender;\n\n    emit DepositedSubAccount(accountId, msg.sender);\n  }\n\n  /**\n   * @notice Allows user to open an account for another user by transferring subAccount NFT.\n   * @dev User must approve contract first\n   * @param accountId subAccount id to transfer\n   * @param recipient recipient address\n   */\n  function depositSubAccountFor(uint accountId, address recipient) external {\n    subAccounts.transferFrom(msg.sender, address(this), accountId);\n    subAccountToOwner[accountId] = recipient;\n\n    emit DepositedSubAccount(accountId, recipient);\n  }\n\n  /**\n   * @notice Activates the cooldown period to withdraw account.\n   */\n  function requestWithdrawAccount(uint accountId) external {\n    if (subAccountToOwner[accountId] != msg.sender) revert SAM_NotOwnerAddress();\n    if (withdrawTimestamp[accountId] != 0) revert SAM_AlreadyRequestedWithdraw();\n\n    withdrawTimestamp[accountId] = block.timestamp;\n\n    emit WithdrawAccountCooldown(accountId, msg.sender);\n  }\n\n  /**\n   * @notice Allows a user to complete their exit from the Matching system.\n   * Can be called by anyone on withdrawable accounts.\n   * @dev User must have previously called `requestWithdrawAccount()` and waited for the cooldown to elapse.\n   * @param accountId The users' accountId\n   */\n  function completeWithdrawAccount(uint accountId) external {\n    if (withdrawTimestamp[accountId] == 0) revert SAM_CooldownNotStarted();\n    if (withdrawTimestamp[accountId] + WITHDRAW_COOLDOWN > block.timestamp) revert SAM_CooldownNotElapsed();\n\n    subAccounts.transferFrom(address(this), subAccountToOwner[accountId], accountId);\n\n    delete withdrawTimestamp[accountId];\n    delete subAccountToOwner[accountId];\n\n    emit WithdrewSubAccount(accountId);\n  }\n}\n"},{"fileName":"interfaces/IActionVerifier.sol","content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.13;\n\nimport {IMatchingModule} from \"./IMatchingModule.sol\";\nimport {ISubAccountsManager} from \"./ISubAccountsManager.sol\";\n\ninterface IActionVerifier is ISubAccountsManager {\n  struct Action {\n    uint subaccountId;\n    uint nonce;\n    IMatchingModule module;\n    bytes data;\n    uint expiry;\n    address owner;\n    address signer;\n  }\n\n  function ACTION_TYPEHASH() external pure returns (bytes32);\n  function DEREGISTER_KEY_COOLDOWN() external pure returns (uint);\n\n  /// @notice Allows other addresses to trade on behalf of others\n  /// @dev Mapping of signer address -> owner address -> expiry\n  function sessionKeys(address signer, address owner) external view returns (uint expiry);\n\n  function registerSessionKey(address toAllow, uint expiry) external;\n  function deregisterSessionKey(address sessionKey) external;\n  function domainSeparator() external view returns (bytes32);\n  function getActionHash(Action memory action) external pure returns (bytes32);\n\n  /**\n   * @dev Emitted when a session key is registered to an owner account.\n   */\n  event SessionKeyRegistered(address owner, address sessionKey, uint expiry);\n\n  /**\n   * @dev Emitted when a user requests to deregister a session key.\n   */\n  event SessionKeyCooldown(address owner, address sessionKeyPublicAddress);\n\n  /// @dev Emitted when user is trying to lower the expiry of a session key\n  error OV_NeedDeregister();\n  error OV_SessionKeyInvalid();\n  error OV_ActionExpired();\n  error OV_InvalidSignature();\n  error OV_InvalidActionOwner();\n  error OV_SignerNotOwnerOrSessionKeyExpired();\n}\n"},{"fileName":"interfaces/IMatching.sol","content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.13;\n\nimport {IActionVerifier} from \"./IActionVerifier.sol\";\n\ninterface IMatching is IActionVerifier {\n  function tradeExecutors(address tradeExecutor) external view returns (bool canExecute);\n  function allowedModules(address tradeExecutor) external view returns (bool canExecute);\n\n  error M_AccountNotReturned();\n  error M_AccountAlreadyExists();\n  error M_ArrayLengthMismatch();\n  error M_OnlyAllowedModule();\n  error M_OnlyTradeExecutor();\n  error M_MismatchedModule();\n\n  ////////////\n  // Events //\n  ////////////\n\n  event TradeExecutorSet(address indexed executor, bool canExecute);\n  event ModuleAllowed(address indexed module, bool allowed);\n}\n"},{"fileName":"interfaces/ISubAccountsManager.sol","content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.13;\n\nimport {ISubAccounts} from \"v2-core/src/interfaces/ISubAccounts.sol\";\nimport {IManager} from \"v2-core/src/interfaces/IManager.sol\";\n\ninterface ISubAccountsManager {\n  function WITHDRAW_COOLDOWN() external view returns (uint);\n\n  function subAccounts() external view returns (ISubAccounts);\n\n  function subAccountToOwner(uint) external view returns (address);\n\n  function withdrawTimestamp(uint) external view returns (uint);\n\n  function createSubAccount(IManager manager) external returns (uint accountId);\n\n  /**\n   * @notice Allows user to open an account by transferring their account NFT to this contract.\n   * @dev User must approve contract first.\n   * @param accountId The users' accountId\n   */\n  function depositSubAccount(uint accountId) external;\n\n  /**\n   * @notice Allows user to open an account for any address by transferring their own account NFT to this contract.\n   */\n  function depositSubAccountFor(uint accountId, address recipient) external;\n\n  /**\n   * @notice Activates the cooldown period to withdraw account.\n   */\n  function requestWithdrawAccount(uint accountId) external;\n\n  /**\n   * @notice Allows a user to complete their exit from the Matching system.\n   * Can be called by anyone on withdrawable accounts.\n   * @dev User must have previously called `requestWithdrawAccount()` and waited for the cooldown to elapse.\n   * @param accountId The users' accountId\n   */\n  function completeWithdrawAccount(uint accountId) external;\n\n  ////////////\n  // Events //\n  ////////////\n\n  /**\n   * @dev Emitted when a CLOB account is added to matching, or generated.\n   */\n  event DepositedSubAccount(uint indexed accountId, address indexed owner);\n\n  /**\n   * @dev Emitted when a CLOB account is closed.\n   */\n  event WithdrewSubAccount(uint indexed accountId);\n\n  /**\n   * @dev Emitted when a user requests account withdrawal and begins the cooldown\n   */\n  event WithdrawAccountCooldown(uint indexed accountId, address user);\n\n  ////////////\n  // Errors //\n  ////////////\n  error SAM_NotOwnerAddress();\n  error SAM_AlreadyRequestedWithdraw();\n  error SAM_CooldownNotStarted();\n  error SAM_CooldownNotElapsed();\n}\n"},{"fileName":"interfaces/IMatchingModule.sol","content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.13;\n\ninterface IMatchingModule {\n  struct VerifiedAction {\n    uint subaccountId;\n    address owner;\n    IMatchingModule module;\n    bytes data;\n    uint nonce;\n  }\n\n  /**\n   * @notice Execute a list of actions\n   * @dev This function is called by the trade executor\n   * @param actions List of signed actions to execute\n   * @param actionData Arbitrary data to pass to the module\n   */\n  function executeAction(VerifiedAction[] memory actions, bytes memory actionData)\n    external\n    returns (uint[] memory newAccIds, address[] memory newOwners);\n}\n"}]}