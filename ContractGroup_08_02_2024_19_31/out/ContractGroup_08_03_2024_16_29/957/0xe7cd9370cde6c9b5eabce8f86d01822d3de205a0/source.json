{"compilerVersion":"v0.8.18+commit.87f61d96","language":"Solidity","remappings":[],"contractFiles":[{"fileName":"risk-managers/BaseManager.sol","content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport \"openzeppelin/access/Ownable2Step.sol\";\nimport \"openzeppelin/utils/math/SafeCast.sol\";\nimport \"openzeppelin/utils/math/Math.sol\";\nimport \"lyra-utils/decimals/DecimalMath.sol\";\nimport \"lyra-utils/decimals/SignedDecimalMath.sol\";\nimport \"lyra-utils/encoding/OptionEncoding.sol\";\n\nimport {ISubAccounts} from \"../interfaces/ISubAccounts.sol\";\nimport {IOptionAsset} from \"../interfaces/IOptionAsset.sol\";\nimport {IPerpAsset} from \"../interfaces/IPerpAsset.sol\";\nimport {ICashAsset} from \"../interfaces/ICashAsset.sol\";\nimport {IForwardFeed} from \"../interfaces/IForwardFeed.sol\";\nimport {IBaseManager} from \"../interfaces/IBaseManager.sol\";\n\nimport {IGlobalSubIdOITracking} from \"../interfaces/IGlobalSubIdOITracking.sol\";\nimport {IDataReceiver} from \"../interfaces/IDataReceiver.sol\";\n\nimport {IForwardFeed} from \"../interfaces/IForwardFeed.sol\";\nimport {IAsset} from \"../interfaces/IAsset.sol\";\nimport {IDutchAuction} from \"../interfaces/IDutchAuction.sol\";\nimport {IManager} from \"../interfaces/IManager.sol\";\nimport {IBasePortfolioViewer} from \"../interfaces/IBasePortfolioViewer.sol\";\n\n/**\n * @title BaseManager\n * @notice Base contract for all managers. Handles OI fee, settling, liquidations and other utility functions.\n */\nabstract contract BaseManager is IBaseManager, Ownable2Step {\n  using DecimalMath for uint;\n  using SignedDecimalMath for int;\n  using SafeCast for uint;\n\n  /// @dev Account contract address\n  ISubAccounts public immutable subAccounts;\n\n  /// @dev Cash asset address\n  ICashAsset public immutable cashAsset;\n\n  /// @dev Dutch auction contract address, can trigger execute bid\n  IDutchAuction public liquidation;\n\n  //////////////////////////\n  //      Variables       //\n  //////////////////////////\n\n  /// @dev Portfolio viewer contract\n  IBasePortfolioViewer public viewer;\n\n  /// @dev the accountId controlled by this manager as intermediate to pay cash if needed\n  uint public immutable accId;\n\n  /// @dev Must be set to a value that the deployment environment can handle the gas cost of the given size.\n  uint public maxAccountSize = 128;\n\n  /// @dev account id that receive OI fee\n  uint public feeRecipientAcc;\n\n  /// @dev The address of guardian, which can pause and unpause adjustments\n  address public guardian;\n\n  /**\n   * @dev If enabled, blocks \"handleAdjustment\" calls. Note, this does not pause manager adjustments such as\n   * liquidations or settlement. This does however block withdrawals, so funds held in the manager cannot exit.\n   */\n  bool public adjustmentsPaused;\n\n  /// @dev minimum OI fee charged, given fee is > 0.\n  uint public minOIFee = 0;\n\n  /// @dev mapping of tradeId => accountId => fee charged\n  mapping(uint => mapping(uint => uint)) public feeCharged;\n\n  /// @dev keep track of the last tradeId that this manager updated before, to prevent double update\n  uint internal lastOracleUpdateTradeId;\n\n  /// @dev tx msg.sender to Accounts that can bypass OI fee on perp or options\n  mapping(address sender => bool) public feeBypassedCaller;\n\n  mapping(address callee => bool) internal whitelistedCallee;\n\n  mapping(address => bool) public trustedRiskAssessor;\n\n  constructor(\n    ISubAccounts _subAccounts,\n    ICashAsset _cashAsset,\n    IDutchAuction _liquidation,\n    IBasePortfolioViewer _viewer\n  ) Ownable2Step() {\n    subAccounts = _subAccounts;\n    cashAsset = _cashAsset;\n    liquidation = _liquidation;\n    viewer = _viewer;\n\n    accId = subAccounts.createAccount(address(this), IManager(address(this)));\n  }\n\n  //////////////////////////\n  // Owner-only Functions //\n  //////////////////////////\n\n  function setLiquidation(IDutchAuction _liquidation) external onlyOwner {\n    if (address(_liquidation) == address(0)) revert BM_InvalidLiquidation();\n    liquidation = _liquidation;\n    emit LiquidationSet(address(_liquidation));\n  }\n\n  /**\n   * @dev Governance determined account to receive OI fee\n   * @param _newAcc account id\n   */\n  function setFeeRecipient(uint _newAcc) external onlyOwner {\n    // this line will revert if the owner tries to set an invalid account\n    subAccounts.ownerOf(_newAcc);\n\n    feeRecipientAcc = _newAcc;\n    emit FeeRecipientSet(_newAcc);\n  }\n\n  function setMinOIFee(uint newMinOIFee) external onlyOwner {\n    if (newMinOIFee > 10000e18) {\n      revert BM_MinOIFeeTooHigh();\n    }\n    minOIFee = newMinOIFee;\n\n    emit MinOIFeeSet(minOIFee);\n  }\n\n  /**\n   * @notice Governance determined tx msg.sender to Accounts that can bypass OI fee on perp or options\n   * @param caller msg.sender to Accounts, caller reported by handleAdjustment\n   * @param bypassed true to bypass OI fee, false to charge OI fee\n   */\n  function setFeeBypassedCaller(address caller, bool bypassed) external onlyOwner {\n    feeBypassedCaller[caller] = bypassed;\n\n    emit FeeBypassedCallerSet(caller, bypassed);\n  }\n\n  /**\n   * @notice Governance determined whitelist that can be called during processManagerData\n   */\n  function setWhitelistedCallee(address callee, bool whitelisted) external onlyOwner {\n    whitelistedCallee[callee] = whitelisted;\n\n    emit CalleeWhitelisted(callee);\n  }\n\n  /**\n   * @dev set max amount of assets in a single account\n   */\n  function setMaxAccountSize(uint _maxAccountSize) external onlyOwner {\n    if (_maxAccountSize < 8 || _maxAccountSize > 500) {\n      revert BM_InvalidMaxAccountSize();\n    }\n    maxAccountSize = _maxAccountSize;\n    emit MaxAccountSizeUpdated(_maxAccountSize);\n  }\n\n  function setTrustedRiskAssessor(address riskAssessor, bool trusted) external onlyOwner {\n    trustedRiskAssessor[riskAssessor] = trusted;\n    emit TrustedRiskAssessorUpdated(riskAssessor, trusted);\n  }\n\n  function setGuardian(address _guardian) external onlyOwner {\n    guardian = _guardian;\n    emit GuardianSet(_guardian);\n  }\n\n  function setAdjustmentsPaused(bool _paused) external {\n    if (msg.sender != guardian) revert BM_GuardianOnly();\n    adjustmentsPaused = _paused;\n    emit AdjustmentsPausedSet(_paused);\n  }\n\n  //////////////////////\n  //   Liquidations   //\n  //////////////////////\n\n  /**\n   * @notice Transfers portion of account to the liquidator.\n   *         Transfers cash to the liquidated account.\n   * @dev Auction contract can decide to either:\n   *      - revert / process bid\n   *      - continue / complete auction\n   * @param accountId ID of account which is being liquidated. assumed to be controlled by this manager\n   * @param liquidatorId Liquidator account ID. assumed to be controlled by this manager\n   * @param portion Portion of account that is requested to be liquidated.\n   * @param bidAmount Cash amount liquidator is offering for portion of account.\n   * @param reservedCash Cash amount to ignore in liquidated account's balance.\n   */\n  function executeBid(uint accountId, uint liquidatorId, uint portion, uint bidAmount, uint reservedCash)\n    external\n    onlyLiquidations\n  {\n    if (portion > 1e18) revert BM_InvalidBidPortion();\n\n    ISubAccounts.AssetBalance[] memory assetBalances = subAccounts.getAccountBalances(accountId);\n\n    // transfer liquidated account's asset to liquidator\n    for (uint i; i < assetBalances.length; i++) {\n      int ignoreAmount = 0;\n      if (assetBalances[i].asset == cashAsset) {\n        ignoreAmount = reservedCash.toInt256();\n      }\n\n      _symmetricManagerAdjustment(\n        accountId,\n        liquidatorId,\n        assetBalances[i].asset,\n        uint96(assetBalances[i].subId),\n        (assetBalances[i].balance - ignoreAmount).multiplyDecimal(int(portion))\n      );\n    }\n\n    if (bidAmount != 0) {\n      // transfer cash (bid amount) to liquidated account\n      _symmetricManagerAdjustment(liquidatorId, accountId, cashAsset, 0, int(bidAmount));\n    }\n  }\n\n  /**\n   * @dev the liquidation module can request manager to pay the liquidation fee from liquidated account at start of auction\n   * @param accountId Account paying the fee (liquidated)\n   * @param recipient Account receiving the fee, may NOT be controlled by this manager\n   */\n  function payLiquidationFee(uint accountId, uint recipient, uint cashAmount) external onlyLiquidations {\n    _transferCash(accountId, recipient, cashAmount.toInt256());\n  }\n\n  /**\n   * @dev settle pending interest on an account\n   * @param accountId account id\n   */\n  function settleInterest(uint accountId) external {\n    subAccounts.managerAdjustment(ISubAccounts.AssetAdjustment(accountId, cashAsset, 0, 0, bytes32(0)));\n  }\n\n  //////////////////////////\n  //  Internal Functions  //\n  //////////////////////////\n\n  function _preAdjustmentHooks(\n    uint accountId,\n    uint tradeId,\n    address caller,\n    ISubAccounts.AssetDelta[] memory assetDeltas,\n    bytes calldata managerData\n  ) internal {\n    if (adjustmentsPaused) revert BM_AdjustmentsPaused();\n    _processManagerData(tradeId, managerData);\n    viewer.checkAllAssetCaps(IManager(this), accountId, tradeId);\n    _chargeAllOIFee(caller, accountId, tradeId, assetDeltas);\n  }\n\n  function _chargeAllOIFee(\n    address, /*caller*/\n    uint, /*accountId*/\n    uint, /*tradeId*/\n    ISubAccounts.AssetDelta[] memory /*assetDeltas*/\n  ) internal virtual {\n    // Each manager must implement their own logic to charge OI fee\n    revert BM_NotImplemented();\n  }\n\n  /**\n   * @dev send custom data to oracles. Oracles should implement the verification logic on their own\n   */\n  function _processManagerData(uint tradeId, bytes calldata managerData) internal {\n    if (managerData.length == 0 || lastOracleUpdateTradeId == tradeId) return;\n\n    lastOracleUpdateTradeId = tradeId;\n\n    // parse array of data and update each oracle or take action\n    ManagerData[] memory managerDatas = abi.decode(managerData, (ManagerData[]));\n    for (uint i; i < managerDatas.length; i++) {\n      // invoke some actions if needed\n      if (!whitelistedCallee[managerDatas[i].receiver]) revert BM_UnauthorizedCall();\n      IDataReceiver(managerDatas[i].receiver).acceptData(managerDatas[i].data);\n    }\n  }\n\n  function _checkIfLiveAuction(uint accountId) internal view {\n    if (liquidation.isAuctionLive(accountId)) {\n      revert BM_AccountUnderLiquidation();\n    }\n  }\n\n  ////////////////\n  //   OI Fee   //\n  ////////////////\n\n  /**\n   * @dev calculate the option OI fee for a specific option + subId combination\n   * @dev if the OI after a batched trade is increased, all participants will be charged a fee if he trades this asset\n   * @param asset Option contract\n   * @param forwardFeed Forward feed contract\n   * @param delta Change in this trade\n   * @param subId SubId of the option\n   */\n  function _getOptionOIFee(IGlobalSubIdOITracking asset, IForwardFeed forwardFeed, int delta, uint subId, uint tradeId)\n    internal\n    view\n    returns (uint fee)\n  {\n    (uint expiry,,) = OptionEncoding.fromSubId(subId.toUint96());\n    (uint forwardPrice,) = forwardFeed.getForwardPrice(uint64(expiry));\n    fee = viewer.getAssetOIFee(asset, subId, delta, tradeId, forwardPrice);\n  }\n\n  /**\n   * @notice calculate the perpetual OI fee.\n   * @dev if the OI after a batched trade is increased, all participants will be charged a fee if he trades this asset\n   */\n  function _getPerpOIFee(IPerpAsset perpAsset, int delta, uint tradeId) internal view returns (uint fee) {\n    (uint perpPrice,) = perpAsset.getPerpPrice();\n    fee = viewer.getAssetOIFee(perpAsset, 0, delta, tradeId, perpPrice);\n  }\n\n  /**\n   * @dev Pay fee, carry up to minFee\n   */\n  function _payFee(uint accountId, uint fee) internal {\n    // Only consider min fee if expected fee is > 0\n    if (fee == 0 || feeRecipientAcc == 0) return;\n\n    // transfer cash to fee recipient account\n    _symmetricManagerAdjustment(accountId, feeRecipientAcc, cashAsset, 0, int(Math.max(fee, minOIFee)));\n  }\n\n  //////////////////////////\n  //     Settlement       //\n  //////////////////////////\n\n  /**\n   * @dev settle an account by removing all expired option positions and adjust cash balance\n   * @dev this function will not revert even if settlement price is not updated\n   * @param accountId Account Id to settle\n   */\n  function _settleAccountOptions(IOptionAsset option, uint accountId) internal {\n    ISubAccounts.AssetBalance[] memory balances = subAccounts.getAccountBalances(accountId);\n    int cashDelta = 0;\n    for (uint i; i < balances.length; i++) {\n      // skip non option asset\n      if (balances[i].asset != option) continue;\n\n      (int value, bool isSettled) = option.calcSettlementValue(balances[i].subId, balances[i].balance);\n      if (!isSettled) continue;\n\n      cashDelta += value;\n\n      // update user option balance\n      subAccounts.managerAdjustment(\n        ISubAccounts.AssetAdjustment(accountId, option, balances[i].subId, -(balances[i].balance), bytes32(0))\n      );\n\n      emit OptionSettled(accountId, address(option), balances[i].subId, balances[i].balance, value);\n    }\n\n    // update user cash amount\n    subAccounts.managerAdjustment(ISubAccounts.AssetAdjustment(accountId, cashAsset, 0, cashDelta, bytes32(0)));\n    // report total print / burn to cash asset\n    cashAsset.updateSettledCash(cashDelta);\n  }\n\n  /**\n   * @notice to settle an account, clear PNL and funding in the perp contract and pay out cash\n   * @dev this should only be called after a perp transfer happens on this account\n   */\n  function _settlePerpRealizedPNL(IPerpAsset perp, uint accountId) internal {\n    // settle perp: update latest funding rate and settle\n    (int pnl, int funding) = perp.settleRealizedPNLAndFunding(accountId);\n\n    int netCash = pnl + funding;\n\n    emit PerpSettled(accountId, address(perp), pnl, funding);\n\n    if (netCash == 0) return;\n\n    cashAsset.updateSettledCash(netCash);\n\n    // update user cash amount\n    subAccounts.managerAdjustment(ISubAccounts.AssetAdjustment(accountId, cashAsset, 0, netCash, bytes32(0)));\n  }\n\n  /**\n   * @notice settle account's perp position with index price, and settle through cash\n   * @dev calling function should make sure perp address is trusted\n   */\n  function _settlePerpUnrealizedPNL(IPerpAsset perp, uint accountId) internal {\n    perp.realizeAccountPNL(accountId);\n\n    _settlePerpRealizedPNL(perp, accountId);\n  }\n\n  /**\n   * @dev transfer asset from one account to another without invoking manager hook\n   * @param from Account id of the from account. Must be controlled by this manager\n   * @param to Account id of the to account. Must be controlled by this manager\n   * @param asset Asset address to transfer\n   * @param subId Asset subId to transfer\n   * @param amount Amount of asset to transfer\n   */\n  function _symmetricManagerAdjustment(uint from, uint to, IAsset asset, uint96 subId, int amount) internal {\n    // deduct amount in from account\n    subAccounts.managerAdjustment(\n      ISubAccounts.AssetAdjustment({acc: from, asset: asset, subId: subId, amount: -amount, assetData: bytes32(0)})\n    );\n\n    // increase \"to\" account\n    subAccounts.managerAdjustment(\n      ISubAccounts.AssetAdjustment({acc: to, asset: asset, subId: subId, amount: amount, assetData: bytes32(0)})\n    );\n  }\n\n  /**\n   * @dev transfer asset from one account to another without invoking manager hook\n   * @param from Account id of the from account. Must be controlled by this manager\n   * @param to Account id of the to account. May not be controlled by this manager\n   */\n  function _transferCash(uint from, uint to, int amount) internal {\n    // deduct amount in from account\n    subAccounts.managerAdjustment(\n      ISubAccounts.AssetAdjustment({acc: from, asset: cashAsset, subId: 0, amount: -amount, assetData: bytes32(0)})\n    );\n\n    // check if recipient under the same manager\n    if (address(subAccounts.manager(to)) == address(this)) {\n      // increase to account balance directly\n      subAccounts.managerAdjustment(\n        ISubAccounts.AssetAdjustment({acc: to, asset: cashAsset, subId: 0, amount: amount, assetData: bytes32(0)})\n      );\n    } else {\n      // mint cash to this account\n      subAccounts.managerAdjustment(\n        ISubAccounts.AssetAdjustment({acc: accId, asset: cashAsset, subId: 0, amount: amount, assetData: bytes32(0)})\n      );\n      subAccounts.submitTransfer(\n        ISubAccounts.AssetTransfer({\n          fromAcc: accId,\n          toAcc: to,\n          asset: cashAsset,\n          subId: 0,\n          amount: amount,\n          assetData: \"\"\n        }),\n        \"\"\n      );\n    }\n  }\n\n  /////////////////////\n  //    Modifier     //\n  /////////////////////\n\n  modifier onlyLiquidations() {\n    if (msg.sender != address(liquidation)) revert BM_OnlyLiquidationModule();\n    _;\n  }\n\n  modifier onlyAccounts() {\n    if (msg.sender != address(subAccounts)) revert BM_OnlyAccounts();\n    _;\n  }\n}\n"},{"fileName":"risk-managers/PMRM.sol","content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport \"openzeppelin/utils/math/SafeCast.sol\";\nimport \"openzeppelin/utils/math/Math.sol\";\nimport \"openzeppelin/utils/math/SignedMath.sol\";\nimport \"openzeppelin/security/ReentrancyGuard.sol\";\n\nimport \"lyra-utils/encoding/OptionEncoding.sol\";\nimport \"lyra-utils/decimals/DecimalMath.sol\";\nimport \"lyra-utils/decimals/SignedDecimalMath.sol\";\n\nimport {IManager} from \"../interfaces/IManager.sol\";\nimport {ISubAccounts} from \"../interfaces/ISubAccounts.sol\";\nimport {ICashAsset} from \"../interfaces/ICashAsset.sol\";\nimport {IPerpAsset} from \"../interfaces/IPerpAsset.sol\";\nimport {IPMRMLib} from \"../interfaces/IPMRMLib.sol\";\nimport {IOptionAsset} from \"../interfaces/IOptionAsset.sol\";\nimport {ISpotFeed} from \"../interfaces/ISpotFeed.sol\";\nimport {ILiquidatableManager} from \"../interfaces/ILiquidatableManager.sol\";\nimport {IVolFeed} from \"../interfaces/IVolFeed.sol\";\nimport {IInterestRateFeed} from \"../interfaces/IInterestRateFeed.sol\";\nimport {IPMRM} from \"../interfaces/IPMRM.sol\";\nimport {IWrappedERC20Asset} from \"../interfaces/IWrappedERC20Asset.sol\";\nimport {IDutchAuction} from \"../interfaces/IDutchAuction.sol\";\nimport {IForwardFeed} from \"../interfaces/IForwardFeed.sol\";\nimport {IBasePortfolioViewer} from \"../interfaces/IBasePortfolioViewer.sol\";\n\nimport {BaseManager} from \"./BaseManager.sol\";\n\n/**\n * @title PMRM\n * @author Lyra\n * @notice Risk Manager that uses a SPAN like methodology to margin an options portfolio.\n */\n\ncontract PMRM is IPMRM, ILiquidatableManager, BaseManager, ReentrancyGuard {\n  using SignedDecimalMath for int;\n  using DecimalMath for uint;\n  using SafeCast for uint;\n  using SafeCast for int;\n\n  IOptionAsset public immutable option;\n  IPerpAsset public immutable perp;\n  IWrappedERC20Asset public immutable baseAsset;\n\n  /////////////////\n  //  Variables  //\n  /////////////////\n\n  ISpotFeed public spotFeed;\n  IInterestRateFeed public interestRateFeed;\n  IVolFeed public volFeed;\n  ISpotFeed public stableFeed;\n  IForwardFeed public forwardFeed;\n\n  /// @dev lib contract\n  IPMRMLib public immutable lib;\n\n  /// @dev Value to help optimise the arranging of portfolio. Should be minimised if possible.\n  uint public maxExpiries = 11;\n\n  IPMRM.Scenario[] internal marginScenarios;\n\n  ////////////////////////\n  //    Constructor     //\n  ////////////////////////\n\n  constructor(\n    ISubAccounts subAccounts_,\n    ICashAsset cashAsset_,\n    IOptionAsset option_,\n    IPerpAsset perp_,\n    IWrappedERC20Asset baseAsset_,\n    IDutchAuction liquidation_,\n    Feeds memory feeds_,\n    IBasePortfolioViewer viewer_,\n    IPMRMLib lib_\n  ) BaseManager(subAccounts_, cashAsset_, liquidation_, viewer_) {\n    spotFeed = feeds_.spotFeed;\n    stableFeed = feeds_.stableFeed;\n    forwardFeed = feeds_.forwardFeed;\n    interestRateFeed = feeds_.interestRateFeed;\n    volFeed = feeds_.volFeed;\n    lib = lib_;\n\n    baseAsset = baseAsset_;\n    option = option_;\n    perp = perp_;\n  }\n\n  /////////////////////\n  //   Owner-only    //\n  /////////////////////\n\n  /**\n   * @dev set max tradeable expiries in a single account\n   */\n  function setMaxExpiries(uint _maxExpiries) external onlyOwner {\n    if (_maxExpiries <= maxExpiries || _maxExpiries > 30) {\n      revert PMRM_InvalidMaxExpiries();\n    }\n    maxExpiries = _maxExpiries;\n    emit MaxExpiriesUpdated(_maxExpiries);\n  }\n\n  function setInterestRateFeed(IInterestRateFeed _interestRateFeed) external onlyOwner {\n    interestRateFeed = _interestRateFeed;\n    emit InterestRateFeedUpdated(_interestRateFeed);\n  }\n\n  function setVolFeed(IVolFeed _volFeed) external onlyOwner {\n    volFeed = _volFeed;\n    emit VolFeedUpdated(_volFeed);\n  }\n\n  function setSpotFeed(ISpotFeed _spotFeed) external onlyOwner {\n    spotFeed = _spotFeed;\n    emit SpotFeedUpdated(_spotFeed);\n  }\n\n  function setStableFeed(ISpotFeed _stableFeed) external onlyOwner {\n    stableFeed = _stableFeed;\n    emit StableFeedUpdated(_stableFeed);\n  }\n\n  function setForwardFeed(IForwardFeed _forwardFeed) external onlyOwner {\n    forwardFeed = _forwardFeed;\n    emit ForwardFeedUpdated(_forwardFeed);\n  }\n\n  /**\n   * @notice Sets the scenarios for managing margin positions.\n   * @dev Only the contract owner can invoke this function.\n   * @param _scenarios An array of Scenario structs representing the margin scenarios.\n   *                   Each Scenario struct contains relevant data for a specific scenario.\n   */\n  function setScenarios(IPMRM.Scenario[] memory _scenarios) external onlyOwner {\n    if (_scenarios.length == 0 || _scenarios.length > 40) {\n      revert PMRM_InvalidScenarios();\n    }\n    for (uint i = 0; i < _scenarios.length; i++) {\n      if (_scenarios[i].spotShock > 3e18) {\n        revert PMRM_InvalidSpotShock();\n      }\n      if (marginScenarios.length <= i) {\n        marginScenarios.push(_scenarios[i]);\n      } else {\n        marginScenarios[i] = _scenarios[i];\n      }\n    }\n\n    uint marginScenariosLength = marginScenarios.length;\n    for (uint i = _scenarios.length; i < marginScenariosLength; i++) {\n      marginScenarios.pop();\n    }\n    emit ScenariosUpdated(_scenarios);\n  }\n\n  ///////////////////////\n  //   Account Hooks   //\n  ///////////////////////\n\n  /**\n   * @notice Handles adjustments to the margin positions for a given account.\n   * @dev Only the accounts contract can invoke this function.\n   * @param accountId The ID of the account.\n   * @param tradeId The ID of the trade.\n   * @param caller The address of the caller.\n   * @param assetDeltas An array of AssetDelta structs representing changes to account assets.\n   * @param managerData Additional data (unused in this function).\n   */\n  function handleAdjustment(\n    uint accountId,\n    uint tradeId,\n    address caller,\n    ISubAccounts.AssetDelta[] memory assetDeltas,\n    bytes calldata managerData\n  ) external onlyAccounts nonReentrant {\n    _preAdjustmentHooks(accountId, tradeId, caller, assetDeltas, managerData);\n\n    // Block any transfers where an account is under liquidation\n    _checkIfLiveAuction(accountId);\n\n    bool riskAdding = false;\n    for (uint i = 0; i < assetDeltas.length; i++) {\n      if (assetDeltas[i].asset == perp) {\n        // Settle perp PNL into cash if the user traded perp in this tx.\n        _settlePerpRealizedPNL(perp, accountId);\n        riskAdding = true;\n      } else if (\n        assetDeltas[i].asset != cashAsset && assetDeltas[i].asset != option && assetDeltas[i].asset != baseAsset\n      ) {\n        revert PMRM_UnsupportedAsset();\n      } else {\n        if (assetDeltas[i].delta < 0) {\n          riskAdding = true;\n        }\n      }\n    }\n\n    ISubAccounts.AssetBalance[] memory assetBalances = subAccounts.getAccountBalances(accountId);\n\n    if (\n      assetBalances.length > maxAccountSize //\n        && viewer.getPreviousAssetsLength(assetBalances, assetDeltas) < assetBalances.length\n    ) {\n      revert PMRM_TooManyAssets();\n    }\n\n    if (!riskAdding) {\n      // Early exit if only adding cash/option/baseAsset\n      return;\n    }\n    _assessRisk(caller, accountId, assetBalances);\n  }\n\n  ///////////////////////\n  // Arrange Portfolio //\n  ///////////////////////\n\n  event ShadowTrustedVsUntrustedRiskAssessment(\n    uint accountId,\n    int trustedMM, \n    int untrustedMM,\n    int untrustedIM\n  );\n\n\n  function _assessRisk(address caller, uint accountId, ISubAccounts.AssetBalance[] memory assetBalances) internal {\n    IPMRM.Portfolio memory portfolio = _arrangePortfolio(accountId, assetBalances);\n\n    if (trustedRiskAssessor[caller]) {\n      // If the caller is a trusted risk assessor, only use the basis contingency scenarios (3 scenarios)\n      (int atmMM,,) = lib.getMarginAndMarkToMarket(portfolio, false, lib.getBasisContingencyScenarios());\n\n      //////////////////\n      // Shadow Start //\n      //////////////////\n      \n      // compare trusted vs un-trusted risk assessment\n      (int postMM,,) = lib.getMarginAndMarkToMarket(portfolio, false, marginScenarios);\n      (int postIM,,) = lib.getMarginAndMarkToMarket(portfolio, true, marginScenarios);\n\n      emit ShadowTrustedVsUntrustedRiskAssessment(accountId, atmMM, postMM, postIM);\n\n\n      ////////////////\n      // Shadow End //\n      ////////////////\n\n      if (atmMM >= 0) return;\n    } else {\n      // If the caller is not a trusted risk assessor, use all the margin scenarios\n      (int postIM,,) = lib.getMarginAndMarkToMarket(portfolio, true, marginScenarios);\n      if (postIM >= 0) return;\n    }\n\n    revert PMRM_InsufficientMargin();\n  }\n\n  /**\n   * @notice Arrange portfolio into cash + arranged\n   *         array of [strikes][calls / puts / forwards].\n   * @param assets Array of balances for given asset and subId.\n   * @return portfolio Cash + option holdings.\n   */\n  function _arrangePortfolio(uint accountId, ISubAccounts.AssetBalance[] memory assets)\n    internal\n    view\n    returns (IPMRM.Portfolio memory portfolio)\n  {\n    (uint seenExpiries, PortfolioExpiryData[] memory expiryCount) = _countExpiriesAndOptions(assets);\n\n    portfolio.expiries = new ExpiryHoldings[](seenExpiries);\n    (portfolio.spotPrice, portfolio.minConfidence) = spotFeed.getSpot();\n    (uint stablePrice,) = stableFeed.getSpot();\n    portfolio.stablePrice = stablePrice;\n\n    _initialiseExpiries(portfolio, expiryCount);\n    _arrangeOptions(accountId, portfolio, assets, expiryCount);\n\n    if (portfolio.perpPosition != 0) {\n      (uint perpPrice, uint perpConfidence) = perp.getPerpPrice();\n      portfolio.perpPrice = perpPrice;\n      portfolio.minConfidence = Math.min(portfolio.minConfidence, perpConfidence);\n    }\n\n    portfolio = lib.addPrecomputes(portfolio);\n\n    return portfolio;\n  }\n\n  function _countExpiriesAndOptions(ISubAccounts.AssetBalance[] memory assets)\n    internal\n    view\n    returns (uint seenExpiries, IPMRM.PortfolioExpiryData[] memory expiryCount)\n  {\n    uint assetLen = assets.length;\n\n    seenExpiries = 0;\n    expiryCount = new IPMRM.PortfolioExpiryData[](maxExpiries > assetLen ? assetLen : maxExpiries);\n\n    // Just count the number of options per expiry\n    for (uint i = 0; i < assetLen; ++i) {\n      ISubAccounts.AssetBalance memory currentAsset = assets[i];\n      if (address(currentAsset.asset) == address(option)) {\n        (uint optionExpiry,,) = OptionEncoding.fromSubId(currentAsset.subId.toUint96());\n\n        bool found = false;\n        for (uint j = 0; j < seenExpiries; j++) {\n          if (expiryCount[j].expiry == optionExpiry) {\n            expiryCount[j].optionCount++;\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          if (seenExpiries == maxExpiries) {\n            revert PMRM_TooManyExpiries();\n          }\n          expiryCount[seenExpiries++] = PortfolioExpiryData({expiry: uint64(optionExpiry), optionCount: 1});\n        }\n      }\n    }\n\n    return (seenExpiries, expiryCount);\n  }\n\n  /**\n   * @dev initial array of empty ExpiryHolding structs in the portfolio struct\n   */\n  function _initialiseExpiries(IPMRM.Portfolio memory portfolio, PortfolioExpiryData[] memory expiryCount)\n    internal\n    view\n  {\n    for (uint i = 0; i < portfolio.expiries.length; ++i) {\n      (uint forwardFixedPortion, uint forwardVariablePortion, uint fwdConfidence) =\n        forwardFeed.getForwardPricePortions(expiryCount[i].expiry);\n      (int rate, uint rateConfidence) = interestRateFeed.getInterestRate(expiryCount[i].expiry);\n      // We dont compare this to the portfolio.minConfidence yet - we do that in preComputes\n      uint minConfidence = Math.min(fwdConfidence, rateConfidence);\n\n      // if an option expired, also set secToExpiry to 0\n      uint64 secToExpiry =\n        expiryCount[i].expiry > uint64(block.timestamp) ? uint64(expiryCount[i].expiry - block.timestamp) : 0;\n      portfolio.expiries[i] = ExpiryHoldings({\n        expiry: expiryCount[i].expiry,\n        secToExpiry: secToExpiry,\n        options: new StrikeHolding[](expiryCount[i].optionCount),\n        forwardFixedPortion: forwardFixedPortion,\n        forwardVariablePortion: forwardVariablePortion,\n        // We assume the rate is always positive\n        rate: SignedMath.max(0, rate).toUint256(),\n        minConfidence: minConfidence,\n        netOptions: 0,\n        // vol shocks are added in addPrecomputes\n        mtm: 0,\n        basisScenarioUpMtM: 0,\n        basisScenarioDownMtM: 0,\n        volShockUp: 0,\n        volShockDown: 0,\n        staticDiscount: 0\n      });\n    }\n  }\n\n  function _arrangeOptions(\n    uint accountId,\n    IPMRM.Portfolio memory portfolio,\n    ISubAccounts.AssetBalance[] memory assets,\n    PortfolioExpiryData[] memory expiryCount\n  ) internal view {\n    for (uint i = 0; i < assets.length; ++i) {\n      ISubAccounts.AssetBalance memory currentAsset = assets[i];\n      if (address(currentAsset.asset) == address(option)) {\n        (uint optionExpiry, uint strike, bool isCall) = OptionEncoding.fromSubId(currentAsset.subId.toUint96());\n\n        uint expiryIndex = findInArray(portfolio.expiries, optionExpiry, portfolio.expiries.length);\n\n        ExpiryHoldings memory expiry = portfolio.expiries[expiryIndex];\n\n        (uint vol, uint confidence) = volFeed.getVol(strike.toUint128(), optionExpiry.toUint64());\n\n        expiry.minConfidence = Math.min(confidence, expiry.minConfidence);\n\n        expiry.netOptions += SignedMath.abs(currentAsset.balance);\n\n        uint index = --expiryCount[expiryIndex].optionCount;\n        expiry.options[index] =\n          StrikeHolding({strike: strike, vol: vol, amount: currentAsset.balance, isCall: isCall, seenInFilter: false});\n      } else if (address(currentAsset.asset) == address(cashAsset)) {\n        portfolio.cash = currentAsset.balance;\n      } else if (address(currentAsset.asset) == address(perp)) {\n        portfolio.perpPosition = currentAsset.balance;\n        portfolio.perpValue = perp.getUnsettledAndUnrealizedCash(accountId);\n      } else if (address(currentAsset.asset) == address(baseAsset)) {\n        portfolio.basePosition = currentAsset.balance.toUint256();\n      } // No need to catch other assets, as they will be caught in handleAdjustment\n    }\n  }\n\n  /**\n   * @dev Return index of expiry in the array, revert if not found\n   */\n  function findInArray(ExpiryHoldings[] memory expiryData, uint expiryToFind, uint arrayLen)\n    internal\n    pure\n    returns (uint index)\n  {\n    unchecked {\n      for (uint i; i < arrayLen; ++i) {\n        if (expiryData[i].expiry == expiryToFind) {\n          return i;\n        }\n      }\n      revert PMRM_FindInArrayError();\n    }\n  }\n\n  /**\n   * @dev Iterate through all asset delta, charge OI fee for perp and option assets\n   */\n  function _chargeAllOIFee(address caller, uint accountId, uint tradeId, ISubAccounts.AssetDelta[] memory assetDeltas)\n    internal\n    override\n  {\n    if (feeBypassedCaller[caller]) return;\n\n    uint fee;\n    // iterate through all asset changes, if it's option asset, change if OI increased\n    for (uint i; i < assetDeltas.length; i++) {\n      if (address(assetDeltas[i].asset) == address(option)) {\n        fee += _getOptionOIFee(option, forwardFeed, assetDeltas[i].delta, assetDeltas[i].subId, tradeId);\n      } else if (address(assetDeltas[i].asset) == address(perp)) {\n        fee += _getPerpOIFee(perp, assetDeltas[i].delta, tradeId);\n      }\n    }\n\n    _payFee(accountId, fee);\n  }\n\n  ////////////////\n  //  External  //\n  ////////////////\n\n  /**\n   * @notice Can be called by anyone to settle a perp asset in an account\n   */\n  function settlePerpsWithIndex(uint accountId) external {\n    _settlePerpUnrealizedPNL(perp, accountId);\n  }\n\n  /**\n   * @notice Can be called by anyone to settle a perp asset in an account\n   */\n  function settleOptions(IOptionAsset _option, uint accountId) external {\n    if (_option != option) revert PMRM_UnsupportedAsset();\n    _settleAccountOptions(_option, accountId);\n  }\n\n  ////////////\n  //  View  //\n  ////////////\n\n  /**\n   * @notice Return all scenarios\n   */\n  function getScenarios() external view returns (IPMRM.Scenario[] memory) {\n    return marginScenarios;\n  }\n\n  /**\n   * @notice Turn balance into an arranged portfolio struct\n   */\n  function arrangePortfolio(uint accountId) external view returns (IPMRM.Portfolio memory portfolio) {\n    return _arrangePortfolio(accountId, subAccounts.getAccountBalances(accountId));\n  }\n\n  /**\n   * @notice Get the initial margin or maintenance margin of an account\n   * @dev if the returned value is negative, it means the account is under margin requirement\n   */\n  function getMargin(uint accountId, bool isInitial) external view returns (int) {\n    IPMRM.Portfolio memory portfolio = _arrangePortfolio(accountId, subAccounts.getAccountBalances(accountId));\n    (int margin,,) = lib.getMarginAndMarkToMarket(portfolio, isInitial, marginScenarios);\n    return margin;\n  }\n\n  /**\n   * @notice Get margin level and mark to market of an account\n   */\n  function getMarginAndMarkToMarket(uint accountId, bool isInitial, uint scenarioId)\n    external\n    view\n    returns (int margin, int mtm)\n  {\n    IPMRM.Portfolio memory portfolio = _arrangePortfolio(accountId, subAccounts.getAccountBalances(accountId));\n    IPMRM.Scenario[] memory scenarios = new IPMRM.Scenario[](1);\n\n    scenarios[0] = marginScenarios[scenarioId];\n\n    (margin, mtm,) = lib.getMarginAndMarkToMarket(portfolio, isInitial, scenarios);\n    return (margin, mtm);\n  }\n}\n"},{"fileName":"interfaces/IInterestRateModel.sol","content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IInterestRateModel {\n  /**\n   * @notice Function to calculate the interest on debt balances\n   *\n   * @param elapsedTime Seconds since last interest accrual\n   * @param borrowRate The current borrow rate for the asset\n   * @return Interest factor accumlated in the elapsedTime\n   */\n  function getBorrowInterestFactor(uint elapsedTime, uint borrowRate) external pure returns (uint);\n\n  /**\n   * @notice Calculates the current borrow rate as a linear equation\n   * @param supply The supplied amount of stablecoin for the asset\n   * @param borrows The amount of borrows in the market\n   * @return The borrow rate percentage as a mantissa\n   */\n  function getBorrowRate(uint supply, uint borrows) external view returns (uint);\n\n  /**\n   * @notice Calculates the utilization rate of the market: `borrows / supply`\n   * @param supply The supplied amount of stablecoin for the asset\n   * @param borrows The amount of borrows for the asset\n   * @return The utilization rate as a mantissa between\n   */\n  function getUtilRate(uint supply, uint borrows) external pure returns (uint);\n\n  ////////////\n  // Events //\n  ////////////\n\n  /// @dev Emitted when interest rate parameters are set\n  event InterestRateParamsSet(uint minRate, uint rateMultiplier, uint highRateMultiplier, uint optimalUtil);\n\n  ////////////\n  // Errors //\n  ////////////\n\n  /// @dev Revert when the parameter set is greater than 1e18\n  error IRM_InvalidParamBound();\n  error IRM_NoElapsedTime(uint elapsedTime);\n}\n"},{"fileName":"interfaces/IWrappedERC20Asset.sol","content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IERC20BasedAsset} from \"./IERC20BasedAsset.sol\";\nimport {IPositionTracking} from \"./IPositionTracking.sol\";\n\ninterface IWrappedERC20Asset is IERC20BasedAsset, IPositionTracking {\n  //////////////\n  //  Errors  //\n  //////////////\n  error WERC_OnlyAccountOwner();\n  error WERC_CannotBeNegative();\n  error WERC_InvalidSubId();\n}\n"},{"fileName":"interfaces/IPMRM.sol","content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {ISpotFeed} from \"./ISpotFeed.sol\";\nimport {IForwardFeed} from \"./IForwardFeed.sol\";\nimport {IInterestRateFeed} from \"./IInterestRateFeed.sol\";\nimport {IVolFeed} from \"./IVolFeed.sol\";\n\ninterface IPMRM {\n  enum VolShockDirection {\n    None,\n    Up,\n    Down\n  }\n\n  struct Feeds {\n    ISpotFeed spotFeed;\n    ISpotFeed stableFeed;\n    IForwardFeed forwardFeed;\n    IInterestRateFeed interestRateFeed;\n    IVolFeed volFeed;\n  }\n\n  struct Portfolio {\n    uint spotPrice;\n    uint perpPrice;\n    uint stablePrice;\n    /// cash amount or debt\n    int cash;\n    /// option holdings per expiry\n    ExpiryHoldings[] expiries;\n    int perpPosition;\n    uint basePosition;\n    uint baseValue;\n    int totalMtM;\n    // Calculated values\n    int basisContingency;\n    // option + base + perp; excludes fwd/oracle\n    uint staticContingency;\n    uint confidenceContingency;\n    uint minConfidence;\n    int perpValue;\n  }\n\n  struct ExpiryHoldings {\n    // used as key\n    uint expiry;\n    uint secToExpiry;\n    StrikeHolding[] options;\n    // portion unaffected by spot shocks\n    uint forwardFixedPortion;\n    // portion affected by spot shocks\n    uint forwardVariablePortion;\n    // We always assume the rate is >= 0\n    uint rate;\n    uint minConfidence;\n    uint netOptions;\n    int mtm;\n    int basisScenarioUpMtM;\n    int basisScenarioDownMtM;\n    uint volShockUp;\n    uint volShockDown;\n    uint staticDiscount;\n  }\n\n  struct StrikeHolding {\n    /// strike price of held options\n    uint strike;\n    uint vol;\n    int amount;\n    bool isCall;\n    bool seenInFilter;\n  }\n\n  struct PortfolioExpiryData {\n    uint64 expiry;\n    uint optionCount;\n  }\n\n  struct Scenario {\n    uint spotShock; // i.e. 1.2e18 = 20% spot shock up\n    VolShockDirection volShock; // i.e. [Up, Down, None]\n  }\n\n  ////////////////\n  //   Events   //\n  ////////////////\n  event MaxExpiriesUpdated(uint maxExpiries);\n  event InterestRateFeedUpdated(IInterestRateFeed interestRateFeed);\n  event VolFeedUpdated(IVolFeed volFeed);\n  event SpotFeedUpdated(ISpotFeed spotFeed);\n  event StableFeedUpdated(ISpotFeed stableFeed);\n  event ForwardFeedUpdated(IForwardFeed forwardFeed);\n  event ScenariosUpdated(IPMRM.Scenario[] scenarios);\n\n  ////////////\n  // Errors //\n  ////////////\n  error PMRM_InvalidSpotShock();\n  error PMRM_UnsupportedAsset();\n  error PMRM_InsufficientMargin();\n  error PMRM_InvalidScenarios();\n  error PMRM_InvalidMaxExpiries();\n  error PMRM_FindInArrayError();\n  error PMRM_OptionExpired();\n  error PMRM_TooManyExpiries();\n  error PMRM_TooManyAssets();\n}\n"},{"fileName":"interfaces/IGlobalSubIdOITracking.sol","content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IGlobalSubIdOITracking {\n  struct SubIdOISnapshot {\n    bool initialized;\n    uint240 oi;\n  }\n\n  function openInterestBeforeTrade(uint subId, uint tradeId) external view returns (bool, uint240);\n\n  function openInterest(uint subId) external view returns (uint);\n\n  /// @dev Emitted when oi is snapshot for given subId\n  event SubIdSnapshotTaken(uint subId, uint tradeId, uint oi);\n}\n"},{"fileName":"interfaces/ISubAccounts.sol","content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IERC721} from \"openzeppelin/token/ERC721/IERC721.sol\";\nimport {IAsset} from \"./IAsset.sol\";\nimport {IManager} from \"./IManager.sol\";\n\nimport {IAllowances} from \"./IAllowances.sol\";\n\n// For full documentation refer to src/SubAccounts.sol\";\ninterface ISubAccounts is IERC721 {\n  struct BalanceAndOrder {\n    // balance of (asset, subId)\n    int240 balance;\n    // index in heldAssets() or getAccountBalances()\n    uint16 order;\n  }\n\n  struct HeldAsset {\n    IAsset asset;\n    uint96 subId;\n  }\n\n  struct AssetDelta {\n    IAsset asset;\n    uint96 subId;\n    int delta;\n  }\n\n  // the struct is used to easily manage 2 dimensional array\n  struct AssetDeltaArrayCache {\n    uint used;\n    AssetDelta[100] deltas;\n  }\n\n  /////////////////////////\n  // Memory-only Structs //\n  /////////////////////////\n\n  struct AssetBalance {\n    IAsset asset;\n    // adjustments will revert if > uint96\n    uint subId;\n    // base layer only stores up to int240\n    int balance;\n  }\n\n  struct AssetTransfer {\n    // debited by amount\n    uint fromAcc;\n    // credited by amount\n    uint toAcc;\n    // asset contract address\n    IAsset asset;\n    // adjustments will revert if >uint96\n    uint subId;\n    // reverts if transfer amount > uint240\n    int amount;\n    // data passed into asset.handleAdjustment()\n    bytes32 assetData;\n  }\n\n  struct AssetAdjustment {\n    uint acc;\n    IAsset asset;\n    // reverts for subIds > uint96\n    uint subId;\n    // reverts if transfer amount > uint240\n    int amount;\n    // data passed into asset.handleAdjustment()\n    bytes32 assetData;\n  }\n\n  ///////////////////\n  // Account Admin //\n  ///////////////////\n\n  /**\n   * @notice Creates account with new accountId\n   * @param owner new account owner\n   * @param _manager IManager of new account\n   * @return newId ID of new account\n   */\n  function createAccount(address owner, IManager _manager) external returns (uint newId);\n\n  /**\n   * @notice Creates account and gives spender full allowance\n   * @dev   @note: can be used to create and account for another user and simultaneously give allowance to oneself\n   * @param owner new account owner\n   * @param spender give address ERC721 approval\n   * @param _manager IManager of new account\n   * @return newId ID of new account\n   */\n  function createAccountWithApproval(address owner, address spender, IManager _manager) external returns (uint newId);\n\n  ///////////////\n  // Approvals //\n  ///////////////\n\n  /**\n   * @notice Sets bidirectional allowances for all subIds of an asset.\n   *         During a balance adjustment, if msg.sender not ERC721 approved or owner,\n   *         asset allowance + subId allowance must be >= amount\n   * @param accountId ID of account\n   * @param delegate address to assign allowance to\n   * @param allowances positive and negative amounts for each asset\n   */\n  function setAssetAllowances(uint accountId, address delegate, IAllowances.AssetAllowance[] memory allowances)\n    external;\n\n  /**\n   * @notice Sets bidirectional allowances for a specific subId.\n   *         During a balance adjustment, the subId allowance is decremented first\n   * @param accountId ID of account\n   * @param delegate address to assign allowance to\n   * @param allowances positive and negative amounts for each (asset, subId)\n   */\n  function setSubIdAllowances(uint accountId, address delegate, IAllowances.SubIdAllowance[] memory allowances)\n    external;\n\n  /////////////////////////\n  // Balance Adjustments //\n  /////////////////////////\n\n  /**\n   * @notice Transfer an amount from one account to another for a specific (asset, subId)\n   * @param assetTransfer (fromAcc, toAcc, asset, subId, amount)\n   * @param managerData data passed to managers of both accounts\n   */\n  function submitTransfer(AssetTransfer memory assetTransfer, bytes memory managerData) external returns (uint tradeId);\n\n  /**\n   * @notice Batch several transfers\n   *         Gas efficient when modifying the same account several times,\n   *         as _managerHook() is only performed once per account\n   * @param assetTransfers array of (fromAcc, toAcc, asset, subId, amount)\n   * @param managerData data passed to every manager involved in trade\n   */\n  function submitTransfers(AssetTransfer[] memory assetTransfers, bytes memory managerData)\n    external\n    returns (uint tradeId);\n\n  /**\n   * @notice Asymmetric balance adjustment reserved for assets\n   *         Must still pass both _managerHook()\n   * @param adjustment asymmetric adjustment of amount for (asset, subId)\n   * @param triggerAssetHook true if the adjustment need to be routed to Asset's custom hook\n   * @param managerData data passed to manager of account\n   */\n  function assetAdjustment(AssetAdjustment memory adjustment, bool triggerAssetHook, bytes memory managerData)\n    external\n    returns (int postBalance);\n\n  /**\n   * @notice Assymetric balance adjustment reserved for managers\n   *         Must still pass both _assetHook()\n   * @param adjustment assymetric adjustment of amount for (asset, subId)\n   */\n  function managerAdjustment(AssetAdjustment memory adjustment) external returns (int postBalance);\n\n  //////////\n  // View //\n  //////////\n\n  /**\n   * @dev return the manager address of the account\n   * @param accountId ID of account\n   */\n  function manager(uint accountId) external view returns (IManager);\n\n  /**\n   * @dev return the tradeId for when the account was last interacted with\n   * @param accountId ID of account\n   */\n  function lastAccountTradeId(uint accountId) external view returns (uint lastTradeId);\n\n  /**\n   * @dev return amount of asset in the account, and the order (index) of the asset in the asset array\n   * @param accountId ID of account\n   * @param asset IAsset of balance\n   * @param subId subId of balance\n   */\n  function balanceAndOrder(uint accountId, IAsset asset, uint subId)\n    external\n    view\n    returns (int240 balance, uint16 order);\n\n  /**\n   * @notice Gets an account's balance for an (asset, subId)\n   * @param accountId ID of account\n   * @param asset IAsset of balance\n   * @param subId subId of balance\n   */\n  function getBalance(uint accountId, IAsset asset, uint subId) external view returns (int balance);\n\n  /**\n   * @notice Gets a list of all asset balances of an account\n   * @dev can use balanceAndOrder() to get the index of a specific balance\n   * @param accountId ID of account\n   */\n  function getAccountBalances(uint accountId) external view returns (AssetBalance[] memory assetBalances);\n\n  /**\n   * @dev get unique assets from heldAssets.\n   *      heldAssets can hold multiple entries with same asset but different subId\n   * @param accountId ID of account\n   * @return uniqueAssets list of address\n   */\n  function getUniqueAssets(uint accountId) external view returns (address[] memory uniqueAssets);\n\n  ////////////\n  // Events //\n  ////////////\n\n  /**\n   * @dev Emitted account created or split\n   */\n  event AccountCreated(address indexed owner, uint indexed accountId, address indexed manager);\n\n  /**\n   * @dev Emitted account burned\n   */\n  event AccountBurned(address indexed owner, uint indexed accountId, address indexed manager);\n\n  /**\n   * @dev Emitted when account manager changed\n   */\n  event AccountManagerChanged(uint indexed accountId, address indexed oldManager, address indexed newManager);\n\n  /**\n   * @dev Emitted when user invalidate set of nonces\n   */\n  event UnorderedNonceInvalidated(address owner, uint wordPos, uint mask);\n\n  event AssetTransferred(\n    uint indexed fromAcc, uint indexed toAcc, IAsset asset, uint subId, int amount, bytes32 assetData, uint tradeId\n  );\n\n  /**\n   * @dev Emitted during any balance change event. This includes:\n   *      1. single transfer\n   *      2. batch transfer\n   *      3. transferAll / merge / split\n   *      4. manager or asset initiated adjustments\n   *      PreBalance + amount not necessarily = postBalance\n   */\n  event BalanceAdjusted(\n    uint indexed accountId,\n    address indexed manager,\n    bytes32 indexed assetAndSubId,\n    int amount,\n    int preBalance,\n    int postBalance,\n    uint tradeId\n  );\n\n  ////////////\n  // Errors //\n  ////////////\n\n  error AC_OnlyManager();\n\n  error AC_OnlyAsset();\n\n  error AC_TooManyTransfers();\n\n  error AC_NotOwnerOrERC721Approved(address spender, uint accountId, address owner, IManager manager, address approved);\n\n  error AC_CannotTransferAssetToOneself(address caller, uint accountId);\n\n  error AC_CannotChangeToSameManager(address caller, uint accountId);\n\n  error AC_InvalidPermitSignature();\n\n  error AC_SignatureExpired();\n\n  /// @dev nonce already used.\n  error AC_InvalidNonce();\n}\n"},{"fileName":"interfaces/IAllowances.sol","content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IAsset} from \"./IAsset.sol\";\n\n// For full documentation refer to src/Allowances.sol\";\ninterface IAllowances {\n  ////////////////\n  // Allowances //\n  ////////////////\n\n  struct AssetAllowance {\n    IAsset asset;\n    uint positive;\n    uint negative;\n  }\n\n  struct SubIdAllowance {\n    IAsset asset;\n    uint subId;\n    uint positive;\n    uint negative;\n  }\n\n  struct PermitAllowance {\n    // who to approve\n    address delegate;\n    // nonce for each signer\n    uint nonce;\n    // access are granted on account bases. A signer can have multiple accounts and the signature cannot be\n    // applied to permit another account\n    uint accountId;\n    // deadline on the permit signature\n    uint deadline;\n    // array of \"asset allowance\" to set\n    IAllowances.AssetAllowance[] assetAllowances;\n    // array of \"subid allowance\" to set\n    SubIdAllowance[] subIdAllowances;\n  }\n\n  ///////////\n  // Views //\n  ///////////\n\n  function positiveSubIdAllowance(uint accountId, address owner, IAsset asset, uint subId, address spender)\n    external\n    view\n    returns (uint);\n\n  function negativeSubIdAllowance(uint accountId, address owner, IAsset asset, uint subId, address spender)\n    external\n    view\n    returns (uint);\n\n  function positiveAssetAllowance(uint accountId, address owner, IAsset asset, address spender)\n    external\n    view\n    returns (uint);\n\n  function negativeAssetAllowance(uint accountId, address owner, IAsset asset, address spender)\n    external\n    view\n    returns (uint);\n\n  ////////////\n  // Errors //\n  ////////////\n\n  error NotEnoughSubIdOrAssetAllowances(\n    address caller, uint accountId, int amount, uint subIdAllowance, uint assetAllowance\n  );\n}\n"},{"fileName":"interfaces/ILiquidatableManager.sol","content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IBaseManager} from \"./IBaseManager.sol\";\nimport {IPerpAsset} from \"./IPerpAsset.sol\";\nimport {IOptionAsset} from \"./IOptionAsset.sol\";\n\ninterface ILiquidatableManager is IBaseManager {\n  /**\n   * @notice can be called by anyone to settle all perp asset in an account\n   */\n  function settlePerpsWithIndex(uint accountId) external;\n\n  /**\n   * @notice can be called by anyone to settle option assets in an account\n   */\n  function settleOptions(IOptionAsset _option, uint accountId) external;\n\n  /**\n   * @dev get initial margin or maintenance margin\n   */\n  function getMargin(uint accountId, bool isInitial) external view returns (int);\n\n  function getMarginAndMarkToMarket(uint accountId, bool isInitial, uint scenarioId) external view returns (int, int);\n}\n"},{"fileName":"interfaces/IPerpAsset.sol","content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IAsset} from \"./IAsset.sol\";\nimport {IPositionTracking} from \"./IPositionTracking.sol\";\nimport {IGlobalSubIdOITracking} from \"./IGlobalSubIdOITracking.sol\";\n\n/**\n * @title IPerpAsset\n * @notice Interface for a perpetual asset contract that extends the IAsset interface.\n */\ninterface IPerpAsset is IAsset, IPositionTracking, IGlobalSubIdOITracking {\n  struct PositionDetail {\n    // Spot price the last time user interact with perp contract\n    uint lastMarkPrice;\n    // All funding, not yet settled as cash in Accounts\n    int funding;\n    // Realized pnl, not yet settled as cash in Accounts\n    int pnl;\n    // Last aggregated funding applied to this position.\n    int lastAggregatedFunding;\n    // Timestamp of the last time funding was applied\n    uint lastFundingPaid;\n  }\n\n  /**\n   * @notice Manager-only function to clear pnl and funding during settlement\n   * @dev The manager should then update the cash balance of an account base on the returned netCash variable\n   */\n  function settleRealizedPNLAndFunding(uint accountId) external returns (int pnl, int funding);\n\n  function getUnsettledAndUnrealizedCash(uint accountId) external view returns (int totalCash);\n\n  function realizeAccountPNL(uint account) external;\n\n  function getIndexPrice() external view returns (uint, uint);\n\n  function getPerpPrice() external view returns (uint, uint);\n\n  function getImpactPrices() external view returns (uint bid, uint ask);\n\n  //////////////////\n  //   Events     //\n  //////////////////\n\n  event StaticUnderlyingInterestRateUpdated(int premium);\n\n  event SpotFeedUpdated(address spotFeed);\n\n  event PerpFeedUpdated(address perpFeed);\n\n  event ImpactFeedsUpdated(address askImpactFeed, address bidImpactFeed);\n\n  event RateBoundsUpdated(int maxAbsRatePerHour);\n\n  event ConvergencePeriodUpdated(int fundingConvergencePeriod);\n\n  event Disabled(int indexPrice, int aggregatedFunding);\n\n  event AggregatedFundingUpdated(int aggregatedFundingRate, int fundingRate, uint lastFundingPaidAt);\n\n  event FundingAppliedOnAccount(uint accountId, int funding, int aggregatedFundingRate);\n\n  event PositionSettled(uint indexed account, int pnlChange, int totalPnl, uint perpPrice);\n\n  event PositionCleared(uint indexed account);\n\n  ////////////////\n  //   Errors   //\n  ////////////////\n\n  /// @dev SubId is not 0\n  error PA_InvalidSubId();\n\n  /// @dev Settlement can only be initiated by the manager of the account\n  error PA_WrongManager();\n\n  /// @dev Impact prices are invalid: bids higher than ask or negative\n  error PA_InvalidImpactPrices();\n\n  error PA_InvalidRateBounds();\n\n  error PA_InvalidConvergencePeriod();\n\n  error PA_InvalidStaticInterestRate();\n}\n"},{"fileName":"interfaces/IForwardFeed.sol","content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\n/**\n * @title IForwardFeed\n * @author Lyra\n * @notice return forward feed for 1 asset\n */\n\ninterface IForwardFeed {\n  /**\n   * @notice Gets forward price for a particular asset\n   * @param expiry Forward expiry to query\n   */\n  function getForwardPrice(uint64 expiry) external view returns (uint forwardPrice, uint confidence);\n  function getForwardPricePortions(uint64 expiry)\n    external\n    view\n    returns (uint forwardFixedPortion, uint forwardVariablePortion, uint confidence);\n}\n"},{"fileName":"interfaces/IVolFeed.sol","content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IVolFeed {\n  function getVol(uint128 strike, uint64 expiry) external view returns (uint vol, uint confidence);\n\n  function getExpiryMinConfidence(uint64 expiry) external view returns (uint confidence);\n\n  ////////////\n  // Events //\n  ////////////\n\n  /// @dev Emitted when spot price for option settlement determined\n  event VolSet(uint128 strike, uint128 expiry, uint128 vol, uint64 confidence);\n}\n"},{"fileName":"interfaces/IBaseManager.sol","content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IManager} from \"./IManager.sol\";\n\ninterface IBaseManager is IManager {\n  /////////////\n  // Structs //\n  /////////////\n\n  struct ManagerData {\n    address receiver;\n    bytes data;\n  }\n\n  struct SettleUnrealizedPNLData {\n    uint accountId;\n    address perp; // this needs to be verified\n  }\n\n  /**\n   * @notice settle interest for an account\n   */\n  function settleInterest(uint accountId) external;\n\n  function feeCharged(uint tradeId, uint account) external view returns (uint);\n\n  function executeBid(uint accountId, uint liquidatorId, uint portion, uint cashAmount, uint reservedCash) external;\n\n  function payLiquidationFee(uint accountId, uint recipient, uint cashAmount) external;\n\n  function maxAccountSize() external view returns (uint);\n\n  ////////////////\n  //   Events   //\n  ////////////////\n\n  event LiquidationSet(address liquidation);\n\n  event MinOIFeeSet(uint minOIFee);\n\n  event GuardianSet(address guardian);\n\n  event AdjustmentsPausedSet(bool paused);\n\n  event CalleeWhitelisted(address callee);\n\n  event PerpSettled(uint indexed accountId, address perp, int pnl, int funding);\n\n  event OptionSettled(uint indexed accountId, address option, uint subId, int amount, int value);\n\n  event FeeBypassedCallerSet(address caller, bool bypassed);\n\n  event FeeRecipientSet(uint _newAcc);\n\n  event MaxAccountSizeUpdated(uint maxAccountSize);\n\n  event TrustedRiskAssessorUpdated(address riskAssessor, bool trusted);\n\n  ////////////\n  // Errors //\n  ////////////\n\n  error BM_InvalidLiquidation();\n\n  error BM_MinOIFeeTooHigh();\n\n  error BM_GuardianOnly();\n\n  error BM_AdjustmentsPaused();\n\n  error BM_InvalidBidPortion();\n\n  error BM_AccountUnderLiquidation();\n\n  error BM_OnlyLiquidationModule();\n\n  error BM_OnlyAccounts();\n\n  error BM_AssetCapExceeded();\n\n  error BM_UnauthorizedCall();\n\n  error BM_InvalidMaxAccountSize();\n\n  error BM_NotImplemented();\n}\n"},{"fileName":"interfaces/IDutchAuction.sol","content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {ICashAsset} from \"./ICashAsset.sol\";\n\ninterface IDutchAuction {\n  struct Auction {\n    /// the accountId that is being liquidated\n    uint accountId;\n    /// scenario ID used to calculate IM or MtM. Ignored for Basic Manager\n    uint scenarioId;\n    /// Boolean that will be switched when the auction price passes through 0\n    bool insolvent;\n    /// If an auction is active\n    bool ongoing;\n    /// For insolvent auctions, snapshot MM at the time the auction starts\n    uint cachedMM;\n    /// The startTime of the auction\n    uint startTime;\n    /// The total amount of cash paid into the account during the auction\n    uint reservedCash;\n  }\n\n  struct AuctionParams {\n    /// Starting percentage of MtM. 1e18 is 100%\n    uint startingMtMPercentage;\n    /// Percentage that starts the slow auction\n    uint fastAuctionCutoffPercentage;\n    /// Fast auction length in seconds\n    uint fastAuctionLength;\n    /// Slow auction length in seconds\n    uint slowAuctionLength;\n    /// Insolvent auction length in seconds\n    uint insolventAuctionLength;\n    // Liquidator fee rate in percentage, 1e18 = 100%\n    uint liquidatorFeeRate;\n    // Buffer margin percentage, 1.2e18 = 120%\n    uint bufferMarginPercentage;\n  }\n\n  function cash() external view returns (ICashAsset);\n\n  function startAuction(uint accountId, uint scenarioId) external;\n\n  function getIsWithdrawBlocked() external view returns (bool);\n\n  function isAuctionLive(uint accountId) external view returns (bool);\n\n  ////////////\n  // EVENTS //\n  ////////////\n\n  // emitted when a solvent auction starts\n  event SolventAuctionStarted(uint accountId, uint scenarioId, int markToMarket, uint fee);\n\n  // emitted when an insolvent auction starts\n  event InsolventAuctionStarted(uint accountId, uint scenarioId, int maintenanceMargin);\n\n  // emitted when a bid is placed\n  event Bid(uint accountId, uint bidderId, uint finalPercentage, uint cashFromBidder, uint cashToBidder);\n\n  // emitted when an auction ends, either by insolvency or by the assets of an account being purchased.\n  event AuctionEnded(uint accountId, uint endTime);\n\n  event InsolventAuctionStepIncremented(uint accountId, uint newStep);\n\n  event ScenarioIdUpdated(uint accountId, uint newScenarioId);\n\n  event AuctionParamsSet(AuctionParams params);\n\n  event SMAccountSet(uint smAccount);\n\n  ////////////\n  // ERRORS //\n  ////////////\n\n  /// @dev emitted owner is trying to set a bad parameter for auction\n  error DA_InvalidParameter();\n\n  /// @dev emitted owner is trying to set bad threshold that could block cash withdraw\n  error DA_InvalidWithdrawBlockThreshold();\n\n  /// @dev Cannot stop an ongoing auction\n  error DA_NotOngoingAuction();\n\n  /// @dev emitted when someone tries to start an insolvent auction when bidding\n  /// has not concluded.\n  error DA_OngoingSolventAuction();\n\n  /// @dev revert if trying to start an auction when it's above maintenance margin (well collateralized)\n  error DA_AccountIsAboveMaintenanceMargin();\n\n  /// @dev revert if trying to end an auction when it's below maintenance margin\n  error DA_AccountIsBelowMaintenanceMargin();\n\n  /// @dev emitted when someone tries mark an insolvent auction again\n  error DA_AuctionAlreadyInInsolvencyMode();\n\n  /// @dev emitted when someone tries to bid on auction that has not started\n  error DA_AuctionNotStarted();\n\n  /// @dev emitted when a risk manager tries to start an auction that has already been started\n  error DA_AuctionAlreadyStarted();\n\n  /// @dev emitted when a bid is submitted on a solvent auction that has passed the auction time\n  ///      at this point, it can be converted into insolvent auction and keep going.\n  error DA_SolventAuctionEnded();\n\n  /// @dev emitted when a bid is submitted where percentage > 100% of portfolio\n  error DA_InvalidPercentage();\n\n  /// @dev emitted when a bid is submitted and the lastTradeId of the account mismatches the expected value\n  error DA_InvalidLastTradeId();\n\n  /// @dev emitted when a bid is submitted for 0% of the portfolio\n  error DA_AmountIsZero();\n\n  /// @dev emitted when a bidder doesn't have only cash in their portfolio\n  error DA_InvalidBidderPortfolio();\n\n  /// @dev emitted when bidder doesn't have enough cash for bidding\n  error DA_InsufficientCash();\n\n  /// @dev emitted when an bidder bid on an insolvent auction, but the bidder is insolvent\n  error DA_BidderInsolvent();\n\n  /// @dev emitted when bidder specified max cash is exceeded by the bid\n  error DA_PriceLimitExceeded();\n\n  /// @dev emitted when owner trying to set a invalid buffer margin param\n  error DA_InvalidBufferMarginParameter();\n\n  /// @dev emitted when a user doesn't own the account that they are trying to bid from\n  error DA_SenderNotOwner();\n\n  /// @dev emitted when a user tries to terminate an auction but the account is still underwater\n  error DA_AuctionCannotTerminate();\n\n  /// @dev can only specify an id that make the IM worse\n  error DA_ScenarioIdNotWorse();\n\n  /// @dev emitted when a user tries to bid on an auction, but it should be terminated\n  error DA_AuctionShouldBeTerminated();\n\n  /// @dev emitted when reserved cash exceeds MTM. Auction should be terminated and restarted.\n  error DA_ReservedCashGreaterThanMtM();\n\n  /// @dev emitted when calling force liquidate not from the account's manager.\n  error DA_OnlyManager();\n}\n"},{"fileName":"interfaces/IPositionTracking.sol","content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IManager} from \"./IManager.sol\";\n\ninterface IPositionTracking {\n  /////////////////\n  //   Structs   //\n  /////////////////\n\n  struct OISnapshot {\n    bool initialized;\n    uint240 oi;\n  }\n\n  function setTotalPositionCap(IManager manager, uint oiCap) external;\n\n  function totalPositionCap(IManager manager) external view returns (uint);\n\n  function totalPositionBeforeTrade(IManager manager, uint tradeId) external view returns (bool, uint240);\n\n  function totalPosition(IManager manager) external view returns (uint);\n\n  /// @dev Emitted when snapshot is taken for totalOi\n  event SnapshotTaken(address manager, uint tradeId, uint oi);\n\n  /// @dev Emitted when OI cap is set\n  event TotalPositionCapSet(address manager, uint oiCap);\n\n  /// @dev Reverts if total position exceeds cap\n  error PT_CapExceeded();\n}\n"},{"fileName":"interfaces/IERC20BasedAsset.sol","content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport \"openzeppelin/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IAsset} from \"./IAsset.sol\";\n\ninterface IERC20BasedAsset is IAsset {\n  function wrappedAsset() external view returns (IERC20Metadata);\n  function deposit(uint recipientAccount, uint assetAmount) external;\n  function withdraw(uint accountId, uint assetAmount, address recipient) external;\n\n  /// @dev emitted when a user deposits to an account\n  event Deposit(uint indexed accountId, address indexed depositor, uint amountAssetMinted, uint wrappedAssetDeposited);\n\n  /// @dev emitted when a user withdraws from an account\n  event Withdraw(uint indexed accountId, address indexed recipient, uint amountAssetBurn, uint wrappedAssetWithdrawn);\n}\n"},{"fileName":"interfaces/IManager.sol","content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {ISubAccounts} from \"./ISubAccounts.sol\";\n\ninterface IManager {\n  /**\n   * @notice triggered at the end of a tx when any balance of the account is updated\n   * @dev a manager should properly check the final stateo of an account\n   * @param tradeId unique number attached to a batched transfers.\n   *                It is possible that this hook will receive multiple calls with different tradeIds within 1 transaction if there were\n   *                recursive calls to Account.submitTransfer (call submitTrnasfer again in this hook).\n   */\n  function handleAdjustment(\n    uint accountId,\n    uint tradeId,\n    address caller,\n    ISubAccounts.AssetDelta[] memory deltas,\n    bytes memory data\n  ) external;\n}\n"},{"fileName":"interfaces/IPMRMLib.sol","content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IPMRM} from \"./IPMRM.sol\";\n\ninterface IPMRMLib {\n  struct VolShockParameters {\n    /// @dev The max vol shock, that can be scaled down\n    uint volRangeUp;\n    /// @dev The max\n    uint volRangeDown;\n    int shortTermPower;\n    int longTermPower;\n    uint dteFloor;\n  }\n\n  struct MarginParameters {\n    uint imFactor;\n    uint rateMultScale;\n    uint rateAddScale;\n    uint baseStaticDiscount;\n  }\n\n  struct BasisContingencyParameters {\n    uint scenarioSpotUp;\n    uint scenarioSpotDown;\n    uint basisContAddFactor;\n    uint basisContMultFactor;\n  }\n\n  struct OtherContingencyParameters {\n    /// @dev Below this threshold, we consider the stable asset de-pegged, so we add additional contingency\n    uint pegLossThreshold;\n    /// @dev If below the peg loss threshold, we add this contingency\n    uint pegLossFactor;\n    /// @dev Below this threshold, IM is affected by confidence contingency\n    uint confThreshold;\n    /// @dev Percentage of spot used for confidence contingency, scales with the minimum contingency seen.\n    uint confMargin;\n    /// @dev Contingency applied to base held in the portfolio, multiplied by spot.\n    uint basePercent;\n    /// @dev Contingency applied to perps held in the portfolio, multiplied by spot.\n    uint perpPercent;\n    /// @dev Factor for multiplying number of naked shorts (per strike) in the portfolio, multipled by spot.\n    uint optionPercent;\n  }\n\n  function getMarginAndMarkToMarket(IPMRM.Portfolio memory portfolio, bool isInitial, IPMRM.Scenario[] memory scenarios)\n    external\n    view\n    returns (int margin, int markToMarket, uint worstScenario);\n\n  function getScenarioMtM(IPMRM.Portfolio memory portfolio, IPMRM.Scenario memory scenario)\n    external\n    view\n    returns (int scenarioMtM);\n\n  function addPrecomputes(IPMRM.Portfolio memory portfolio) external view returns (IPMRM.Portfolio memory);\n\n  function getBasisContingencyScenarios() external view returns (IPMRM.Scenario[] memory);\n\n  ////////////\n  // Errors //\n  ////////////\n\n  /// @dev emitted when provided forward contingency parameters are invalid\n  error PMRML_InvalidBasisContingencyParameters();\n  /// @dev emitted when provided other contingency parameters are invalid\n  error PMRML_InvalidOtherContingencyParameters();\n  /// @dev emitted when provided static discount parameters are invalid\n  error PMRML_InvalidMarginParameters();\n  /// @dev emitted when provided vol shock parameters are invalid\n  error PMRML_InvalidVolShockParameters();\n  /// @dev emitted when invalid parameters passed into _getMarginAndMarkToMarket\n  error PMRML_InvalidGetMarginState();\n}\n"},{"fileName":"interfaces/ICashAsset.sol","content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IAsset} from \"./IAsset.sol\";\nimport {IInterestRateModel} from \"./IInterestRateModel.sol\";\nimport {IManager} from \"./IManager.sol\";\nimport {IERC20Metadata} from \"openzeppelin/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IERC20BasedAsset} from \"./IERC20BasedAsset.sol\";\n\ninterface ICashAsset is IERC20BasedAsset {\n  /**\n   * @dev Deposit and create a new account\n   * @param recipient user for who the new account is created\n   * @param stableAmount amount of stable coins to deposit\n   * @param manager manager of the new account\n   */\n  function depositToNewAccount(address recipient, uint stableAmount, IManager manager)\n    external\n    returns (uint newAccountId);\n\n  /**\n   * @notice Liquidation module can report loss when there is insolvency.\n   *         This function will \"print\" the amount of cash to the target account\n   *         and socialize the loss to everyone in the system\n   *         this will result in turning on withdraw fee if the contract is indeed insolvent\n   * @param lossAmountInCash Total amount of cash loss\n   * @param accountToReceive Account to receive the new printed amount\n   */\n  function socializeLoss(uint lossAmountInCash, uint accountToReceive) external;\n\n  /**\n   * @notice Returns latest balance without updating accounts but will update indexes\n   * @param accountId The accountId to check\n   */\n  function calculateBalanceWithInterest(uint accountId) external returns (int balance);\n\n  /**\n   * @dev Returns the exchange rate from cash asset to stable asset\n   *      this should always be equal to 1, unless we have an insolvency\n   */\n  function getCashToStableExchangeRate() external view returns (uint);\n\n  /**\n   * @notice Allows whitelisted manager to adjust netSettledCash\n   * @dev Required to track printed cash for asymmetric settlements\n   * @param amountCash Amount of cash printed or burned\n   */\n  function updateSettledCash(int amountCash) external;\n\n  /**\n   * @notice Allows the account's risk manager to forcefully send all cash to the account owner\n   */\n  function forceWithdraw(uint accountId) external;\n\n  function donateBalance(uint accountId, uint amount) external returns (uint burntAmount);\n\n  ////////////////\n  //   Events   //\n  ////////////////\n\n  /// @dev Emitted when interest related state variables are updated\n  event InterestAccrued(uint interestAccrued, uint borrowIndex, uint supplyIndex, uint totalSupply, uint totalBorrow);\n\n  /// @dev Emitted when the security module fee is set\n  event SmFeeSet(uint fee);\n\n  /// @dev Emitted when the recipient is set\n  event SmFeeRecipientSet(uint recipientAcc);\n\n  /// @dev Emitted when a new liquidation module is set\n  event LiquidationModuleSet(address liquidationModule);\n\n  /// @dev Emitted when a new interest rate model is set\n  event InterestRateModelSet(IInterestRateModel rateModel);\n\n  /// @dev Emitted when asymmetric print/burn occurs for settlement\n  event SettledCashUpdated(int amountChanged, int currentSettledCash);\n\n  /// @dev emitted when withdraw fee is enabled\n  ///      this would imply there is an insolvency and loss is applied to all cash holders\n  event WithdrawFeeEnabled(uint exchangeRate);\n\n  /// @dev emitted when withdraw fee is disabled\n  ///      this can only occur if the cash asset is solvent again\n  event WithdrawFeeDisabled(uint exchangeRate);\n\n  /// @dev emitted when an interest accrued on an existing account's pre balance\n  event InterestAccruedOnAccount(uint indexed accountId, int preBalance, int interestAccrued, uint accountIndex);\n\n  ////////////////\n  //   Errors   //\n  ////////////////\n\n  /// @dev caller is not account\n  error CA_NotAccount();\n\n  /// @dev SubId passed into adjustment is not 0\n  error CA_InvalidSubId();\n\n  /// @dev caller is not the liquidation module\n  error CA_NotLiquidationModule();\n\n  /// @dev revert when user trying to upgrade to a unknown manager\n  error CA_UnknownManager();\n\n  /// @dev caller is not owner of the account\n  error CA_OnlyAccountOwner();\n\n  /// @dev withdraw is temporarily block due to on-going insolvent auction\n  error CA_WithdrawBlockedByOngoingAuction();\n\n  /// @dev accrued interest is stale\n  error CA_InterestAccrualStale(uint lastUpdatedAt, uint currentTimestamp);\n\n  /// @dev Security module fee cut greater than 100%\n  error CA_SmFeeInvalid(uint fee);\n\n  /// @dev The caller of force withdraw was not the account's risk manager\n  error CA_ForceWithdrawNotAuthorized();\n\n  /// @dev Calling force withdraw when user has a negative balance\n  error CA_ForceWithdrawNegativeBalance();\n\n  /// @dev Only the owner of the account can call the donate function\n  error CA_DonateBalanceNotAuthorized();\n}\n"},{"fileName":"interfaces/IDataReceiver.sol","content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\n/**\n * @title IDataReceiver\n * @author Lyra\n * @notice Interface for oracles that takes data off-chain with signer data\n */\ninterface IDataReceiver {\n  function acceptData(bytes calldata data) external;\n}\n"},{"fileName":"interfaces/IInterestRateFeed.sol","content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IInterestRateFeed {\n  function getInterestRate(uint64 expiry) external view returns (int interestRate, uint confidence);\n}\n"},{"fileName":"interfaces/ISpotFeed.sol","content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\n/**\n * @title ISpotFeed\n * @author Lyra\n * @notice Spot feed adapter\n * @dev `spotPrice` always assumed to return 18 decimal place uint\n */\ninterface ISpotFeed {\n  /**\n   * @notice Gets spot price and confidence\n   * @return spotPrice 18 decimal price of trading pair.\n   */\n  function getSpot() external view returns (uint spotPrice, uint confidence);\n}\n"},{"fileName":"interfaces/IBasePortfolioViewer.sol","content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {ISubAccounts} from \"../interfaces/ISubAccounts.sol\";\n\nimport {IGlobalSubIdOITracking} from \"../interfaces/IGlobalSubIdOITracking.sol\";\nimport {IManager} from \"../interfaces/IManager.sol\";\n\n/**\n * @title IBasePortfolioViewer\n * @author Lyra\n */\ninterface IBasePortfolioViewer {\n  error BM_AssetCapExceeded();\n\n  error BM_OIFeeRateTooHigh();\n\n  function getAssetOIFee(IGlobalSubIdOITracking asset, uint subId, int delta, uint tradeId, uint price)\n    external\n    view\n    returns (uint fee);\n\n  function checkAllAssetCaps(IManager manager, uint accountId, uint tradeId) external view;\n\n  function getPreviousAssetsLength(\n    ISubAccounts.AssetBalance[] memory assetBalances,\n    ISubAccounts.AssetDelta[] memory assetDeltas\n  ) external view returns (uint);\n\n  /// @dev Emitted when OI fee rate is set\n  event OIFeeRateSet(address asset, uint oiFeeRate);\n}\n"},{"fileName":"interfaces/IAsset.sol","content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IManager} from \"./IManager.sol\";\nimport {ISubAccounts} from \"./ISubAccounts.sol\";\n\ninterface IAsset {\n  /**\n   * @notice triggered when an adjustment is triggered on the asset balance\n   * @param adjustment details about adjustment, containing account, subId, amount\n   * @param tradeId unique number attached to a batched transfers.\n   *                It is possible that this hook will receive multiple calls with different tradeIds within 1 transaction.\n   * @param preBalance balance before adjustment\n   * @param manager the manager contract that will verify the end state. Should verify if this is a trusted manager\n   * @param caller the msg.sender that initiate the transfer. might not be the owner\n   * @return finalBalance the final balance to be recorded in the account\n   * @return needAllowance if this adjustment should require allowance from non-ERC721 approved initiator\n   */\n  function handleAdjustment(\n    ISubAccounts.AssetAdjustment memory adjustment,\n    uint tradeId,\n    int preBalance,\n    IManager manager,\n    address caller\n  ) external returns (int finalBalance, bool needAllowance);\n}\n"},{"fileName":"interfaces/IOptionAsset.sol","content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IAsset} from \"./IAsset.sol\";\nimport {IManager} from \"./IManager.sol\";\n\nimport {IPositionTracking} from \"./IPositionTracking.sol\";\nimport {IGlobalSubIdOITracking} from \"./IGlobalSubIdOITracking.sol\";\n\ninterface IOptionAsset is IAsset, IPositionTracking, IGlobalSubIdOITracking {\n  ///////////////////\n  //   Functions   //\n  ///////////////////\n\n  /**\n   * @notice Get settlement value of a specific option.\n   * @dev Will return false if option not settled yet.\n   * @param subId ID of option.\n   * @param balance Amount of option held.\n   * @return payout Amount the holder will receive or pay when position is settled\n   * @return priceSettled Whether the settlement price of the option has been set.\n   */\n  function calcSettlementValue(uint subId, int balance) external view returns (int payout, bool priceSettled);\n\n  ////////////////\n  //   Events   //\n  ////////////////\n  event SettlementFeedSet(address settlementFeed);\n\n  ////////////////\n  //   Errors   //\n  ////////////////\n\n  /// @dev revert if caller is not Accounts\n  error OA_NotAccounts();\n\n  /// @dev revert when settlement is triggered from unknown managers\n  error OA_UnknownManager();\n}\n"}]}